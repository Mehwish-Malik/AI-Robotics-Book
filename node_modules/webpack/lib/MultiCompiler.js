/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const asyncLib = require("neo-async");
const { MultiHook, SyncHook } = require("tapable");

const ConcurrentCompilationError = require("./ConcurrentCompilationError");
const MultiStats = require("./MultiStats");
const MultiWatching = require("./MultiWatching");
const WebpackError = require("./WebpackError");
const ArrayQueue = require("./util/ArrayQueue");

/**
 * @template T
 * @typedef {import("tapable").AsyncSeriesHook<T>} AsyncSeriesHook<T>
 */
/**
 * @template T
 * @template R
 * @typedef {import("tapable").SyncBailHook<T, R>} SyncBailHook<T, R>
 */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */
/** @typedef {import("../declarations/WebpackOptions").WatchOptions} WatchOptions */
/** @typedef {import("./Compiler")} Compiler */
/**
 * @template T
 * @template [R=void]
 * @typedef {import("./webpack").Callback<T, R>} Callback
 */
/** @typedef {import("./webpack").ErrorCallback} ErrorCallback */
/** @typedef {import("./Stats")} Stats */
/** @typedef {import("./logging/Logger").Logger} Logger */
/** @typedef {import("./util/fs").InputFileSystem} InputFileSystem */
/** @typedef {import("./util/fs").IntermediateFileSystem} IntermediateFileSystem */
/** @typedef {import("./util/fs").OutputFileSystem} OutputFileSystem */
/** @typedef {import("./util/fs").WatchFileSystem} WatchFileSystem */

/**
 * @callback RunWithDependenciesHandler
 * @param {Compiler} compiler
 * @param {Callback<MultiStats>} callback
 * @returns {void}
 */

/**
 * @typedef {object} MultiCompilerOptions
 * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel
 */

/** @typedef {ReadonlyArray<WebpackOptions> & MultiCompilerOptions} MultiWebpackOptions */

const CLASS_NAME = "MultiCompiler";

module.exports = class MultiCompiler {
	constructor(compilers, options) {
		if (!Array.isArray(compilers)) {
			compilers = Object.keys(compilers).map((name) => {
				compilers[name].name = name;
				return compilers[name];
			});
		}

		this.compilers = compilers;
		this._options = { parallelism: options.parallelism || Infinity };
		this.dependencies = new WeakMap();
		this.running = false;

		// Initialize MultiCompiler hooks
		this.hooks = Object.freeze({
			done: new SyncHook(["stats"]),
			invalid: new MultiHook(compilers.map((c) => c.hooks.invalid)),
			run: new MultiHook(compilers.map((c) => c.hooks.run)),
			watchClose: new SyncHook([]),
			watchRun: new MultiHook(compilers.map((c) => c.hooks.watchRun)),
			infrastructureLog: new MultiHook(
				compilers.map((c) => c.hooks.infrastructureLog)
			)
		});

		const compilerStats = this.compilers.map(() => null);
		let doneCompilers = 0;

		for (let index = 0; index < this.compilers.length; index++) {
			const compiler = this.compilers[index];
			const compilerIndex = index;
			let compilerDone = false;

			compiler.hooks.done.tap(CLASS_NAME, (stats) => {
				if (!compilerDone) {
					compilerDone = true;
					doneCompilers++;
				}
				compilerStats[compilerIndex] = stats;
				if (doneCompilers === this.compilers.length) {
					this.hooks.done.call(new MultiStats(compilerStats));
				}
			});

			compiler.hooks.invalid.tap(CLASS_NAME, () => {
				if (compilerDone) {
					compilerDone = false;
					doneCompilers--;
				}
			});
		}

		this._validateCompilersOptions();
	}

	_validateCompilersOptions() {
		if (this.compilers.length < 2) return;
		const addWarning = (compiler, warning) => {
			compiler.hooks.thisCompilation.tap(CLASS_NAME, (compilation) => {
				compilation.warnings.push(warning);
			});
		};
		const cacheNames = new Set();
		for (const compiler of this.compilers) {
			if (compiler.options.cache && "name" in compiler.options.cache) {
				const name = compiler.options.cache.name;
				if (cacheNames.has(name)) {
					addWarning(
						compiler,
						new WebpackError(
							`${compiler.name ? `Compiler with name "${compiler.name}" doesn't use unique cache name. ` : ""}Please set unique "cache.name" option. Name "${name}" already used.`
						)
					);
				} else {
					cacheNames.add(name);
				}
			}
		}
	}

	// … rest of the code stays the same …

};
