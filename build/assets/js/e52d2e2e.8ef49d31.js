"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[695],{5901:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"modules/module-4-ai/chapter-12-decision-making","title":"Chapter 12: Decision Making and Autonomy","description":"Summary","source":"@site/docs/modules/module-4-ai/chapter-12-decision-making.md","sourceDirName":"modules/module-4-ai","slug":"/modules/module-4-ai/chapter-12-decision-making","permalink":"/docs/modules/module-4-ai/chapter-12-decision-making","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/modules/module-4-ai/chapter-12-decision-making.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 11: Machine Learning for Robotics","permalink":"/docs/modules/module-4-ai/chapter-11-learning"},"next":{"title":"Chapter 13: Simulation Environments","permalink":"/docs/modules/module-5-applications/chapter-13-simulation"}}');var i=t(4848),s=t(8453);const a={sidebar_position:3},o="Chapter 12: Decision Making and Autonomy",l={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Introduction to Autonomous Decision Making",id:"introduction-to-autonomous-decision-making",level:2},{value:"Autonomy Requirements",id:"autonomy-requirements",level:3},{value:"Decision Making Architecture",id:"decision-making-architecture",level:3},{value:"Task Planning and Scheduling",id:"task-planning-and-scheduling",level:2},{value:"Hierarchical Task Networks (HTN)",id:"hierarchical-task-networks-htn",level:3},{value:"Partial Order Planning",id:"partial-order-planning",level:3},{value:"Temporal Planning",id:"temporal-planning",level:3},{value:"Contingent Planning",id:"contingent-planning",level:3},{value:"Reasoning Under Uncertainty",id:"reasoning-under-uncertainty",level:2},{value:"Probabilistic Reasoning",id:"probabilistic-reasoning",level:3},{value:"Dempster-Shafer Theory",id:"dempster-shafer-theory",level:3},{value:"Fuzzy Logic",id:"fuzzy-logic",level:3},{value:"Decision Theory",id:"decision-theory",level:3},{value:"Human-Robot Interaction",id:"human-robot-interaction",level:2},{value:"Natural Language Understanding",id:"natural-language-understanding",level:3},{value:"Gesture Recognition",id:"gesture-recognition",level:3},{value:"Social Cues",id:"social-cues",level:3},{value:"Multi-modal Interaction",id:"multi-modal-interaction",level:3},{value:"Multi-modal Interaction Systems",id:"multi-modal-interaction-systems",level:2},{value:"Sensor Fusion for Interaction",id:"sensor-fusion-for-interaction",level:3},{value:"Context Awareness",id:"context-awareness",level:3},{value:"Adaptive Interaction",id:"adaptive-interaction",level:3},{value:"Ethical Considerations",id:"ethical-considerations",level:2},{value:"Safety and Risk Assessment",id:"safety-and-risk-assessment",level:3},{value:"Privacy and Data Protection",id:"privacy-and-data-protection",level:3},{value:"Transparency and Explainability",id:"transparency-and-explainability",level:3},{value:"Bias and Fairness",id:"bias-and-fairness",level:3},{value:"Technical Depth: Mathematical Foundations",id:"technical-depth-mathematical-foundations",level:2},{value:"Markov Decision Processes (MDPs)",id:"markov-decision-processes-mdps",level:3},{value:"Partially Observable MDPs (POMDPs)",id:"partially-observable-mdps-pomdps",level:3},{value:"Planning as Inference",id:"planning-as-inference",level:3},{value:"Game Theory Applications",id:"game-theory-applications",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Service Robotics",id:"service-robotics",level:3},{value:"Industrial Applications",id:"industrial-applications",level:3},{value:"Research and Development",id:"research-and-development",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Uncertainty Management",id:"uncertainty-management",level:3},{value:"Human Acceptance",id:"human-acceptance",level:3},{value:"Safety Assurance",id:"safety-assurance",level:3},{value:"Figure List",id:"figure-list",level:2},{value:"Code Example: Decision Making and Autonomy Implementation",id:"code-example-decision-making-and-autonomy-implementation",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary-1",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-12-decision-making-and-autonomy",children:"Chapter 12: Decision Making and Autonomy"})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter explores the artificial intelligence systems that enable humanoid robots to make autonomous decisions and operate independently. We'll examine task planning, reasoning under uncertainty, human-robot interaction, and the ethical considerations of autonomous robotic systems. Understanding decision-making systems is crucial for creating robots that can operate effectively in complex, dynamic environments without constant human supervision."}),"\n",(0,i.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Design task planning systems for complex robotic behaviors"}),"\n",(0,i.jsx)(e.li,{children:"Implement reasoning systems that handle uncertainty"}),"\n",(0,i.jsx)(e.li,{children:"Create effective human-robot interaction interfaces"}),"\n",(0,i.jsx)(e.li,{children:"Address ethical considerations in autonomous robotics"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate autonomy levels and decision-making capabilities"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task Planning"}),": Decomposing high-level goals into executable actions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reasoning Under Uncertainty"}),": Making decisions with incomplete information"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Human-Robot Interaction"}),": Effective communication and collaboration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Autonomy Levels"}),": Degrees of independent operation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multi-modal Interaction"}),": Combining different interaction modalities"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Ethical AI"}),": Responsible deployment of autonomous systems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Explainable AI"}),": Understanding robot decision-making processes"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-autonomous-decision-making",children:"Introduction to Autonomous Decision Making"}),"\n",(0,i.jsx)(e.p,{children:"Autonomous decision making in humanoid robots involves complex systems that must interpret high-level goals, assess environmental conditions, plan appropriate actions, and execute them while adapting to changes. Unlike pre-programmed robots, autonomous systems must handle uncertainty, learn from experience, and make real-time decisions."}),"\n",(0,i.jsx)(e.h3,{id:"autonomy-requirements",children:"Autonomy Requirements"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Perception"}),": Understanding the environment and robot state\r\n",(0,i.jsx)(e.strong,{children:"Reasoning"}),": Drawing conclusions from available information\r\n",(0,i.jsx)(e.strong,{children:"Planning"}),": Creating sequences of actions to achieve goals\r\n",(0,i.jsx)(e.strong,{children:"Execution"}),": Carrying out planned actions\r\n",(0,i.jsx)(e.strong,{children:"Monitoring"}),": Assessing progress and adapting as needed"]}),"\n",(0,i.jsx)(e.h3,{id:"decision-making-architecture",children:"Decision Making Architecture"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Goal Specification \u2192 Perception \u2192 Reasoning \u2192 Planning \u2192 Execution \u2192 Monitoring\n"})}),"\n",(0,i.jsx)(e.p,{children:"Each component must work seamlessly to enable effective autonomous operation."}),"\n",(0,i.jsx)(e.h2,{id:"task-planning-and-scheduling",children:"Task Planning and Scheduling"}),"\n",(0,i.jsx)(e.h3,{id:"hierarchical-task-networks-htn",children:"Hierarchical Task Networks (HTN)"}),"\n",(0,i.jsx)(e.p,{children:"Decompose complex tasks into simpler subtasks:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Goal: Serve drink\r\n\u251c\u2500\u2500 Navigate to kitchen\r\n\u2502   \u251c\u2500\u2500 Path planning\r\n\u2502   \u2514\u2500\u2500 Obstacle avoidance\r\n\u251c\u2500\u2500 Identify beverage\r\n\u2502   \u251c\u2500\u2500 Object recognition\r\n\u2502   \u2514\u2500\u2500 Classification\r\n\u251c\u2500\u2500 Grasp beverage\r\n\u2502   \u251c\u2500\u2500 Grasp planning\r\n\u2502   \u2514\u2500\u2500 Manipulation\r\n\u2514\u2500\u2500 Deliver to person\r\n    \u251c\u2500\u2500 Person detection\r\n    \u2514\u2500\u2500 Safe handover\n"})}),"\n",(0,i.jsx)(e.h3,{id:"partial-order-planning",children:"Partial Order Planning"}),"\n",(0,i.jsx)(e.p,{children:"Allow flexibility in action ordering while maintaining constraints:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Action A \u2500\u2500\u252c\u2500\u2500\u2192 Action C\r\n           \u2514\u2500\u2500\u2192 Action D \u2190\u2500\u2500 Action B\n"})}),"\n",(0,i.jsx)(e.h3,{id:"temporal-planning",children:"Temporal Planning"}),"\n",(0,i.jsx)(e.p,{children:"Consider timing constraints and concurrent actions:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Time: 0s\u2500\u2500\u2500\u2500\u25005s\u2500\u2500\u2500\u2500\u250010s\u2500\u2500\u2500\u2500\u250015s\r\nA:    [action1........]\r\nB:          [action2...]\r\nC:    [act3][act4]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"contingent-planning",children:"Contingent Planning"}),"\n",(0,i.jsx)(e.p,{children:"Handle uncertain outcomes and alternative plans:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Plan: Go to room\r\n\u251c\u2500\u2500 If door is open \u2192 Walk through\r\n\u251c\u2500\u2500 If door is closed \u2192 Open door \u2192 Walk through\r\n\u2514\u2500\u2500 If door locked \u2192 Find alternative route\n"})}),"\n",(0,i.jsx)(e.h2,{id:"reasoning-under-uncertainty",children:"Reasoning Under Uncertainty"}),"\n",(0,i.jsx)(e.h3,{id:"probabilistic-reasoning",children:"Probabilistic Reasoning"}),"\n",(0,i.jsx)(e.p,{children:"Represent and reason with uncertain information:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Bayesian Networks"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"P(A|B) = P(B|A) * P(A) / P(B)\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Markov Models"}),": Sequences of states with transition probabilities\r\n",(0,i.jsx)(e.strong,{children:"Hidden Markov Models"}),": Observable outputs with hidden states"]}),"\n",(0,i.jsx)(e.h3,{id:"dempster-shafer-theory",children:"Dempster-Shafer Theory"}),"\n",(0,i.jsx)(e.p,{children:"Handle incomplete and conflicting evidence:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Bel(A) \u2264 Pl(A)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where Bel is belief and Pl is plausibility."}),"\n",(0,i.jsx)(e.h3,{id:"fuzzy-logic",children:"Fuzzy Logic"}),"\n",(0,i.jsx)(e.p,{children:"Handle imprecise concepts:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u03bc_tall(height) = {\r\n    0 if height < 160cm,\r\n    (height - 160)/40 if 160 \u2264 height \u2264 200,\r\n    1 if height > 200cm\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"decision-theory",children:"Decision Theory"}),"\n",(0,i.jsx)(e.p,{children:"Make optimal decisions under uncertainty:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Expected Utility = \u03a3 P(outcome_i) * Utility(outcome_i)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"human-robot-interaction",children:"Human-Robot Interaction"}),"\n",(0,i.jsx)(e.h3,{id:"natural-language-understanding",children:"Natural Language Understanding"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent Recognition"}),": Identify user's goal\r\n",(0,i.jsx)(e.strong,{children:"Entity Extraction"}),": Identify relevant objects/locations\r\n",(0,i.jsx)(e.strong,{children:"Dialogue Management"}),": Maintain conversation context"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'User: "Can you bring me the red cup?"\r\n\u251c\u2500\u2500 Intent: Deliver object\r\n\u251c\u2500\u2500 Entity: red cup (object)\r\n\u2514\u2500\u2500 Entity: me (recipient)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"gesture-recognition",children:"Gesture Recognition"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Static Gestures"}),": Hand poses and positions\r\n",(0,i.jsx)(e.strong,{children:"Dynamic Gestures"}),": Hand movements and trajectories\r\n",(0,i.jsx)(e.strong,{children:"Body Language"}),": Posture and movement interpretation"]}),"\n",(0,i.jsx)(e.h3,{id:"social-cues",children:"Social Cues"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Gaze Direction"}),": Understanding attention and focus\r\n",(0,i.jsx)(e.strong,{children:"Proxemics"}),": Respecting personal space\r\n",(0,i.jsx)(e.strong,{children:"Turn-taking"}),": Natural conversation flow\r\n",(0,i.jsx)(e.strong,{children:"Emotional Recognition"}),": Understanding human emotions"]}),"\n",(0,i.jsx)(e.h3,{id:"multi-modal-interaction",children:"Multi-modal Interaction"}),"\n",(0,i.jsx)(e.p,{children:"Combine multiple interaction modalities:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Speech + Gesture"}),": Natural human communication\r\n",(0,i.jsx)(e.strong,{children:"Speech + Vision"}),": Context-aware responses\r\n",(0,i.jsx)(e.strong,{children:"Touch + Vision"}),": Collaborative manipulation"]}),"\n",(0,i.jsx)(e.h2,{id:"multi-modal-interaction-systems",children:"Multi-modal Interaction Systems"}),"\n",(0,i.jsx)(e.h3,{id:"sensor-fusion-for-interaction",children:"Sensor Fusion for Interaction"}),"\n",(0,i.jsx)(e.p,{children:"Combine data from multiple sensors:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Audio Input \u2192 Speech Recognition\r\nVideo Input \u2192 Gesture Recognition\r\nHaptic Input \u2192 Touch Detection\r\n\u2192 Multi-modal Understanding\n"})}),"\n",(0,i.jsx)(e.h3,{id:"context-awareness",children:"Context Awareness"}),"\n",(0,i.jsx)(e.p,{children:"Maintain understanding of interaction context:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Spatial Context"}),": Where interactions occur\r\n",(0,i.jsx)(e.strong,{children:"Temporal Context"}),": When events happen\r\n",(0,i.jsx)(e.strong,{children:"Social Context"}),": Who is involved\r\n",(0,i.jsx)(e.strong,{children:"Activity Context"}),": What is happening"]}),"\n",(0,i.jsx)(e.h3,{id:"adaptive-interaction",children:"Adaptive Interaction"}),"\n",(0,i.jsx)(e.p,{children:"Adjust interaction style based on user:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"User Profiling"}),": Learn user preferences\r\n",(0,i.jsx)(e.strong,{children:"Adaptation Mechanisms"}),": Modify interaction parameters\r\n",(0,i.jsx)(e.strong,{children:"Learning from Feedback"}),": Improve interaction over time"]}),"\n",(0,i.jsx)(e.h2,{id:"ethical-considerations",children:"Ethical Considerations"}),"\n",(0,i.jsx)(e.h3,{id:"safety-and-risk-assessment",children:"Safety and Risk Assessment"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Harm Prevention"}),": Avoid causing physical or psychological harm\r\n",(0,i.jsx)(e.strong,{children:"Risk Mitigation"}),": Identify and minimize potential risks\r\n",(0,i.jsx)(e.strong,{children:"Emergency Protocols"}),": Safe failure modes"]}),"\n",(0,i.jsx)(e.h3,{id:"privacy-and-data-protection",children:"Privacy and Data Protection"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Data Minimization"}),": Collect only necessary data\r\n",(0,i.jsx)(e.strong,{children:"Consent"}),": Obtain explicit permission for data use\r\n",(0,i.jsx)(e.strong,{children:"Security"}),": Protect collected information"]}),"\n",(0,i.jsx)(e.h3,{id:"transparency-and-explainability",children:"Transparency and Explainability"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Explainable AI"}),": Understanding robot decisions\r\n",(0,i.jsx)(e.strong,{children:"Decision Transparency"}),": Clear reasoning processes\r\n",(0,i.jsx)(e.strong,{children:"User Control"}),": Ability to override decisions"]}),"\n",(0,i.jsx)(e.h3,{id:"bias-and-fairness",children:"Bias and Fairness"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Algorithmic Bias"}),": Avoid discriminatory behavior\r\n",(0,i.jsx)(e.strong,{children:"Fair Treatment"}),": Equal interaction regardless of user characteristics\r\n",(0,i.jsx)(e.strong,{children:"Cultural Sensitivity"}),": Respect diverse cultural norms"]}),"\n",(0,i.jsx)(e.h2,{id:"technical-depth-mathematical-foundations",children:"Technical Depth: Mathematical Foundations"}),"\n",(0,i.jsx)(e.h3,{id:"markov-decision-processes-mdps",children:"Markov Decision Processes (MDPs)"}),"\n",(0,i.jsx)(e.p,{children:"Formal framework for sequential decision making:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"MDP = <S, A, T, R, \u03b3>\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"S = state space"}),"\n",(0,i.jsx)(e.li,{children:"A = action space"}),"\n",(0,i.jsx)(e.li,{children:"T = transition function T(s, a, s') = P(s'|s, a)"}),"\n",(0,i.jsx)(e.li,{children:"R = reward function R(s, a)"}),"\n",(0,i.jsx)(e.li,{children:"\u03b3 = discount factor"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"partially-observable-mdps-pomdps",children:"Partially Observable MDPs (POMDPs)"}),"\n",(0,i.jsx)(e.p,{children:"Handle partial observability:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"POMDP = <S, A, T, R, \u03a9, O, \u03b3>\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u03a9 = observation space"}),"\n",(0,i.jsx)(e.li,{children:"O = observation function O(s, o) = P(o|s)"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"planning-as-inference",children:"Planning as Inference"}),"\n",(0,i.jsx)(e.p,{children:"Formulate planning as probabilistic inference:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"P(action_sequence|goal, state) \u221d P(goal|action_sequence, state) * P(action_sequence)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"game-theory-applications",children:"Game Theory Applications"}),"\n",(0,i.jsx)(e.p,{children:"Model multi-agent interactions:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Nash Equilibrium"}),": Stable strategy profiles\r\n",(0,i.jsx)(e.strong,{children:"Stackelberg Games"}),": Leader-follower interactions\r\n",(0,i.jsx)(e.strong,{children:"Cooperative Games"}),": Collaborative decision making"]}),"\n",(0,i.jsx)(e.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsx)(e.h3,{id:"service-robotics",children:"Service Robotics"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Assistive Care"}),": Helping elderly and disabled individuals\r\n",(0,i.jsx)(e.strong,{children:"Hospitality"}),": Customer service and concierge functions\r\n",(0,i.jsx)(e.strong,{children:"Retail"}),": Customer assistance and inventory management"]}),"\n",(0,i.jsx)(e.h3,{id:"industrial-applications",children:"Industrial Applications"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Collaborative Manufacturing"}),": Working alongside humans\r\n",(0,i.jsx)(e.strong,{children:"Quality Inspection"}),": Automated quality control\r\n",(0,i.jsx)(e.strong,{children:"Maintenance"}),": Predictive and preventive maintenance"]}),"\n",(0,i.jsx)(e.h3,{id:"research-and-development",children:"Research and Development"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Scientific Assistance"}),": Laboratory automation\r\n",(0,i.jsx)(e.strong,{children:"Data Collection"}),": Environmental monitoring\r\n",(0,i.jsx)(e.strong,{children:"Experimentation"}),": Autonomous research tasks"]}),"\n",(0,i.jsx)(e.h2,{id:"challenges",children:"Challenges"}),"\n",(0,i.jsx)(e.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,i.jsx)(e.p,{children:"Planning and reasoning in real-time with complex environments."}),"\n",(0,i.jsx)(e.h3,{id:"uncertainty-management",children:"Uncertainty Management"}),"\n",(0,i.jsx)(e.p,{children:"Dealing with sensor noise, model inaccuracies, and environmental changes."}),"\n",(0,i.jsx)(e.h3,{id:"human-acceptance",children:"Human Acceptance"}),"\n",(0,i.jsx)(e.p,{children:"Ensuring humans trust and accept autonomous robotic systems."}),"\n",(0,i.jsx)(e.h3,{id:"safety-assurance",children:"Safety Assurance"}),"\n",(0,i.jsx)(e.p,{children:"Guaranteeing safe operation in all possible scenarios."}),"\n",(0,i.jsx)(e.h2,{id:"figure-list",children:"Figure List"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 12.1"}),": Autonomous decision-making architecture"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 12.2"}),": Task planning hierarchy"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 12.3"}),": Uncertainty reasoning framework"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 12.4"}),": Human-robot interaction modalities"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 12.5"}),": Ethical decision-making process"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"code-example-decision-making-and-autonomy-implementation",children:"Code Example: Decision Making and Autonomy Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nimport random\r\nfrom typing import List, Dict, Tuple, Optional, Any\r\nfrom dataclasses import dataclass\r\nfrom enum import Enum\r\nimport json\r\nfrom datetime import datetime\r\nimport uuid\r\n\r\nclass TaskStatus(Enum):\r\n    PENDING = "pending"\r\n    IN_PROGRESS = "in_progress"\r\n    COMPLETED = "completed"\r\n    FAILED = "failed"\r\n    CANCELLED = "cancelled"\r\n\r\nclass DecisionType(Enum):\r\n    ACTION = "action"\r\n    PLANNING = "planning"\r\n    REASONING = "reasoning"\r\n    INTERACTION = "interaction"\r\n\r\n@dataclass\r\nclass RobotState:\r\n    """Current state of the robot"""\r\n    position: np.ndarray  # [x, y, z] in meters\r\n    orientation: np.ndarray  # [roll, pitch, yaw] in radians\r\n    battery_level: float  # 0.0 to 1.0\r\n    joint_positions: np.ndarray  # Joint angles\r\n    joint_velocities: np.ndarray  # Joint velocities\r\n    gripper_state: float  # 0.0 (open) to 1.0 (closed)\r\n    timestamp: float\r\n\r\n@dataclass\r\nclass Task:\r\n    """A task for the robot to execute"""\r\n    id: str\r\n    name: str\r\n    description: str\r\n    priority: int  # 1 (highest) to 10 (lowest)\r\n    status: TaskStatus\r\n    dependencies: List[str]  # Other task IDs this task depends on\r\n    required_resources: List[str]  # Resources needed\r\n    estimated_duration: float  # in seconds\r\n    actual_duration: float = 0.0\r\n    start_time: Optional[float] = None\r\n    completion_time: Optional[float] = None\r\n    constraints: Dict[str, Any] = None  # Task-specific constraints\r\n\r\n@dataclass\r\nclass Decision:\r\n    """A decision made by the robot"""\r\n    id: str\r\n    decision_type: DecisionType\r\n    context: Dict[str, Any]\r\n    options: List[Dict[str, Any]]\r\n    selected_option: Dict[str, Any]\r\n    confidence: float  # 0.0 to 1.0\r\n    timestamp: float\r\n    rationale: str\r\n\r\nclass UncertaintyModel:\r\n    """Model for reasoning under uncertainty"""\r\n\r\n    def __init__(self):\r\n        self.sensor_noise = {\r\n            \'position\': 0.01,  # 1cm standard deviation\r\n            \'orientation\': 0.017,  # 1 degree standard deviation\r\n            \'force\': 0.5  # 0.5N standard deviation\r\n        }\r\n        self.process_noise = 0.001  # Process model uncertainty\r\n        self.belief_state = {}  # Current beliefs about world state\r\n\r\n    def update_belief(self, sensor_data: Dict[str, float],\r\n                     action_taken: Optional[str] = None) -> Dict[str, float]:\r\n        """Update beliefs based on sensor data and actions"""\r\n        # Simple Kalman filter update for position\r\n        if \'position\' in sensor_data:\r\n            current_pos = self.belief_state.get(\'position\', np.array([0.0, 0.0, 0.0]))\r\n            measurement = np.array(sensor_data[\'position\'])\r\n\r\n            # Update with measurement\r\n            kalman_gain = 0.1  # Simplified constant gain\r\n            new_pos = current_pos + kalman_gain * (measurement - current_pos)\r\n\r\n            self.belief_state[\'position\'] = new_pos\r\n            self.belief_state[\'position_uncertainty\'] = self.sensor_noise[\'position\'] * (1 - kalman_gain)\r\n\r\n        return self.belief_state\r\n\r\n    def calculate_uncertainty(self, variable: str) -> float:\r\n        """Get uncertainty for a specific variable"""\r\n        return self.belief_state.get(f\'{variable}_uncertainty\', 0.0)\r\n\r\n    def sample_from_belief(self, variable: str, num_samples: int = 1) -> np.ndarray:\r\n        """Sample from belief distribution"""\r\n        mean = self.belief_state.get(variable, 0.0)\r\n        uncertainty = self.calculate_uncertainty(variable)\r\n\r\n        if isinstance(mean, (int, float)):\r\n            samples = np.random.normal(mean, uncertainty, num_samples)\r\n        else:\r\n            # For arrays\r\n            samples = np.random.normal(mean, uncertainty, (num_samples,) + mean.shape)\r\n\r\n        return samples\r\n\r\nclass TaskPlanner:\r\n    """System for planning and scheduling robot tasks"""\r\n\r\n    def __init__(self):\r\n        self.tasks: List[Task] = []\r\n        self.active_task: Optional[Task] = None\r\n        self.completed_tasks: List[Task] = []\r\n        self.failed_tasks: List[Task] = []\r\n\r\n    def add_task(self, task: Task) -> str:\r\n        """Add a new task to the plan"""\r\n        self.tasks.append(task)\r\n        return task.id\r\n\r\n    def get_available_tasks(self) -> List[Task]:\r\n        """Get tasks that are ready to be executed"""\r\n        available = []\r\n\r\n        for task in self.tasks:\r\n            if task.status == TaskStatus.PENDING:\r\n                # Check dependencies\r\n                all_deps_met = True\r\n                for dep_id in task.dependencies:\r\n                    dep_task = next((t for t in self.completed_tasks if t.id == dep_id), None)\r\n                    if dep_task is None:\r\n                        all_deps_met = False\r\n                        break\r\n\r\n                if all_deps_met:\r\n                    available.append(task)\r\n\r\n        # Sort by priority\r\n        available.sort(key=lambda t: t.priority)\r\n        return available\r\n\r\n    def prioritize_tasks(self, robot_state: RobotState) -> List[Task]:\r\n        """Re-prioritize tasks based on current state"""\r\n        available_tasks = self.get_available_tasks()\r\n\r\n        # Adjust priorities based on context\r\n        for task in available_tasks:\r\n            # Increase priority for safety-related tasks\r\n            if \'emergency\' in task.name.lower() or \'safety\' in task.name.lower():\r\n                task.priority = min(task.priority, 1)\r\n\r\n            # Consider resource availability\r\n            if \'battery\' in task.required_resources and robot_state.battery_level < 0.3:\r\n                task.priority += 2  # Lower priority if battery is low\r\n\r\n        # Sort by priority\r\n        available_tasks.sort(key=lambda t: t.priority)\r\n        return available_tasks\r\n\r\n    def execute_task(self, task: Task, robot_state: RobotState) -> bool:\r\n        """Execute a single task"""\r\n        task.status = TaskStatus.IN_PROGRESS\r\n        task.start_time = robot_state.timestamp\r\n\r\n        # Simulate task execution\r\n        success = self._simulate_task_execution(task, robot_state)\r\n\r\n        task.completion_time = robot_state.timestamp\r\n        task.actual_duration = task.completion_time - task.start_time if task.start_time else 0\r\n\r\n        if success:\r\n            task.status = TaskStatus.COMPLETED\r\n            self.completed_tasks.append(task)\r\n            self.tasks.remove(task)\r\n            return True\r\n        else:\r\n            task.status = TaskStatus.FAILED\r\n            self.failed_tasks.append(task)\r\n            self.tasks.remove(task)\r\n            return False\r\n\r\n    def _simulate_task_execution(self, task: Task, robot_state: RobotState) -> bool:\r\n        """Simulate task execution with some probability of failure"""\r\n        # Simulate success/failure based on various factors\r\n        base_success_rate = 0.9\r\n\r\n        # Adjust based on task complexity and robot state\r\n        if task.priority > 5:  # Lower priority tasks might have lower success rate\r\n            base_success_rate *= 0.95\r\n\r\n        if robot_state.battery_level < 0.2:\r\n            base_success_rate *= 0.8\r\n\r\n        return random.random() < base_success_rate\r\n\r\nclass HumanRobotInterface:\r\n    """System for human-robot interaction"""\r\n\r\n    def __init__(self):\r\n        self.conversation_context = {}\r\n        self.user_preferences = {}\r\n        self.interaction_history = []\r\n\r\n    def process_speech_input(self, speech: str) -> Dict[str, Any]:\r\n        """Process natural language input"""\r\n        # Simple keyword-based parsing (in reality, this would use NLP models)\r\n        tokens = speech.lower().split()\r\n\r\n        intent = "unknown"\r\n        entities = {}\r\n\r\n        # Intent recognition\r\n        if any(word in tokens for word in ["bring", "fetch", "get", "deliver"]):\r\n            intent = "delivery"\r\n        elif any(word in tokens for word in ["go", "move", "navigate", "go to"]):\r\n            intent = "navigation"\r\n        elif any(word in tokens for word in ["help", "assist", "what", "how"]):\r\n            intent = "request_info"\r\n\r\n        # Entity extraction\r\n        if "water" in tokens or "drink" in tokens:\r\n            entities["object"] = "water"\r\n        elif "cup" in tokens:\r\n            entities["object"] = "cup"\r\n\r\n        if "kitchen" in tokens:\r\n            entities["location"] = "kitchen"\r\n        elif "living room" in tokens:\r\n            entities["location"] = "living_room"\r\n\r\n        return {\r\n            "intent": intent,\r\n            "entities": entities,\r\n            "confidence": 0.8  # Simplified confidence\r\n        }\r\n\r\n    def generate_response(self, intent: str, entities: Dict[str, Any]) -> str:\r\n        """Generate appropriate response to user input"""\r\n        if intent == "delivery":\r\n            obj = entities.get("object", "item")\r\n            return f"OK, I\'ll bring you the {obj}. Where would you like me to deliver it?"\r\n        elif intent == "navigation":\r\n            loc = entities.get("location", "destination")\r\n            return f"OK, I\'ll navigate to the {loc}."\r\n        elif intent == "request_info":\r\n            return "I can help you with various tasks. What would you like me to do?"\r\n        else:\r\n            return "I\'m not sure I understand. Could you please rephrase?"\r\n\r\n    def process_gesture_input(self, gesture_type: str, gesture_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Process gesture input"""\r\n        # Map gestures to actions\r\n        gesture_map = {\r\n            "point_left": "navigate_left",\r\n            "point_right": "navigate_right",\r\n            "wave": "greet",\r\n            "come_here": "approach",\r\n            "stop": "stop"\r\n        }\r\n\r\n        action = gesture_map.get(gesture_type, "unknown")\r\n\r\n        return {\r\n            "action": action,\r\n            "gesture_data": gesture_data,\r\n            "confidence": 0.9\r\n        }\r\n\r\n    def update_user_preferences(self, user_id: str, preferences: Dict[str, Any]):\r\n        """Update user preferences for personalized interaction"""\r\n        if user_id not in self.user_preferences:\r\n            self.user_preferences[user_id] = {}\r\n\r\n        self.user_preferences[user_id].update(preferences)\r\n\r\nclass DecisionMaker:\r\n    """System for making autonomous decisions"""\r\n\r\n    def __init__(self):\r\n        self.uncertainty_model = UncertaintyModel()\r\n        self.decision_history: List[Decision] = []\r\n        self.ethical_constraints = {\r\n            \'avoid_harm\': True,\r\n            \'respect_privacy\': True,\r\n            \'transparency\': True\r\n        }\r\n\r\n    def make_decision(self, decision_type: DecisionType, context: Dict[str, Any]) -> Decision:\r\n        """Make a decision based on context and available options"""\r\n        # Generate options based on decision type\r\n        options = self._generate_options(decision_type, context)\r\n\r\n        # Evaluate options\r\n        best_option = self._evaluate_options(options, context)\r\n\r\n        # Create decision object\r\n        decision = Decision(\r\n            id=str(uuid.uuid4()),\r\n            decision_type=decision_type,\r\n            context=context,\r\n            options=options,\r\n            selected_option=best_option,\r\n            confidence=best_option.get(\'confidence\', 0.8),\r\n            timestamp=datetime.now().timestamp(),\r\n            rationale=best_option.get(\'rationale\', \'Selected based on evaluation criteria\')\r\n        )\r\n\r\n        # Apply ethical constraints\r\n        if not self._check_ethical_constraints(decision):\r\n            # Modify decision to comply with constraints\r\n            decision.selected_option = self._apply_ethical_modifications(decision)\r\n\r\n        self.decision_history.append(decision)\r\n        return decision\r\n\r\n    def _generate_options(self, decision_type: DecisionType, context: Dict[str, Any]) -> List[Dict[str, Any]]:\r\n        """Generate possible options for decision"""\r\n        options = []\r\n\r\n        if decision_type == DecisionType.ACTION:\r\n            # Generate possible actions\r\n            robot_pos = context.get(\'robot_position\', np.array([0, 0, 0]))\r\n            target_pos = context.get(\'target_position\', np.array([1, 1, 0]))\r\n\r\n            # Calculate possible actions\r\n            direction = target_pos - robot_pos\r\n            distance = np.linalg.norm(direction)\r\n\r\n            if distance > 0.1:  # Need to move\r\n                options.append({\r\n                    \'action\': \'move_toward\',\r\n                    \'target\': target_pos,\r\n                    \'expected_outcome\': f\'Move to {target_pos}\',\r\n                    \'cost\': distance,\r\n                    \'confidence\': 0.9\r\n                })\r\n\r\n            options.append({\r\n                \'action\': \'wait\',\r\n                \'target\': robot_pos,\r\n                \'expected_outcome\': \'Remain in current position\',\r\n                \'cost\': 0,\r\n                \'confidence\': 0.95\r\n            })\r\n\r\n        elif decision_type == DecisionType.PLANNING:\r\n            # Generate possible plans\r\n            tasks = context.get(\'available_tasks\', [])\r\n\r\n            for task in tasks[:3]:  # Consider top 3 tasks\r\n                options.append({\r\n                    \'plan\': f\'execute_{task.name}\',\r\n                    \'task_id\': task.id,\r\n                    \'expected_outcome\': f\'Complete task: {task.name}\',\r\n                    \'cost\': task.estimated_duration,\r\n                    \'confidence\': 0.8\r\n                })\r\n\r\n        elif decision_type == DecisionType.REASONING:\r\n            # Generate reasoning options\r\n            belief_state = context.get(\'belief_state\', {})\r\n\r\n            for var, value in belief_state.items():\r\n                if isinstance(value, (int, float)) and var.endswith(\'_uncertainty\'):\r\n                    uncertainty = value\r\n                    options.append({\r\n                        \'reasoning\': f\'assess_uncertainty_{var}\',\r\n                        \'variable\': var.replace(\'_uncertainty\', \'\'),\r\n                        \'uncertainty_level\': \'high\' if uncertainty > 0.1 else \'low\',\r\n                        \'confidence\': 0.8\r\n                    })\r\n\r\n        elif decision_type == DecisionType.INTERACTION:\r\n            # Generate interaction options\r\n            user_intent = context.get(\'user_intent\', \'unknown\')\r\n\r\n            if user_intent == \'delivery\':\r\n                options.append({\r\n                    \'interaction\': \'confirm_delivery_request\',\r\n                    \'expected_outcome\': \'Verify user wants delivery\',\r\n                    \'confidence\': 0.9\r\n                })\r\n                options.append({\r\n                    \'interaction\': \'request_clarification\',\r\n                    \'expected_outcome\': \'Ask for more details\',\r\n                    \'confidence\': 0.85\r\n                })\r\n\r\n        return options\r\n\r\n    def _evaluate_options(self, options: List[Dict[str, Any]], context: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Evaluate and rank options"""\r\n        if not options:\r\n            return {}\r\n\r\n        # Simple evaluation based on cost and confidence\r\n        best_option = options[0]\r\n        best_score = float(\'-inf\')\r\n\r\n        for option in options:\r\n            cost = option.get(\'cost\', 0)\r\n            confidence = option.get(\'confidence\', 0.5)\r\n\r\n            # Calculate score (higher is better)\r\n            score = confidence - (cost * 0.1)  # Penalize high cost\r\n\r\n            if score > best_score:\r\n                best_score = score\r\n                best_option = option\r\n\r\n        # Add rationale\r\n        best_option[\'rationale\'] = f"Selected based on score: {best_score:.3f} (confidence: {best_option.get(\'confidence\', 0)}, cost: {best_option.get(\'cost\', 0)})"\r\n\r\n        return best_option\r\n\r\n    def _check_ethical_constraints(self, decision: Decision) -> bool:\r\n        """Check if decision violates ethical constraints"""\r\n        # This is a simplified check - real systems would be more sophisticated\r\n        selected_action = decision.selected_option.get(\'action\', \'\')\r\n\r\n        # Check for potentially harmful actions\r\n        if \'harm\' in selected_action.lower() or \'damage\' in selected_action.lower():\r\n            return False\r\n\r\n        return True\r\n\r\n    def _apply_ethical_modifications(self, decision: Decision) -> Dict[str, Any]:\r\n        """Modify decision to comply with ethical constraints"""\r\n        # Return a safe alternative\r\n        return {\r\n            \'action\': \'safe_alternative\',\r\n            \'rationale\': \'Original decision modified for safety\',\r\n            \'confidence\': 0.9,\r\n            \'cost\': 0\r\n        }\r\n\r\nclass AutonomySystem:\r\n    """Main autonomy system coordinating all components"""\r\n\r\n    def __init__(self):\r\n        self.task_planner = TaskPlanner()\r\n        self.human_interface = HumanRobotInterface()\r\n        self.decision_maker = DecisionMaker()\r\n        self.current_state = RobotState(\r\n            position=np.array([0.0, 0.0, 0.0]),\r\n            orientation=np.array([0.0, 0.0, 0.0]),\r\n            battery_level=1.0,\r\n            joint_positions=np.zeros(20),  # 20 joints example\r\n            joint_velocities=np.zeros(20),\r\n            gripper_state=0.0,\r\n            timestamp=0.0\r\n        )\r\n\r\n        self.autonomy_level = 2  # 0-5 scale (2 = limited autonomy)\r\n        self.safety_monitoring = True\r\n\r\n    def update_state(self, new_state: RobotState):\r\n        """Update the robot\'s state"""\r\n        self.current_state = new_state\r\n\r\n    def process_user_input(self, input_type: str, input_data: Any) -> str:\r\n        """Process user input and generate response"""\r\n        if input_type == "speech":\r\n            parsed_input = self.human_interface.process_speech_input(input_data)\r\n            response = self.human_interface.generate_response(\r\n                parsed_input["intent"],\r\n                parsed_input["entities"]\r\n            )\r\n\r\n            # Create task based on input if appropriate\r\n            if parsed_input["intent"] in ["delivery", "navigation"]:\r\n                task = Task(\r\n                    id=str(uuid.uuid4()),\r\n                    name=f"{parsed_input[\'intent\']}_task",\r\n                    description=f"Perform {parsed_input[\'intent\']} based on user request",\r\n                    priority=3,\r\n                    status=TaskStatus.PENDING,\r\n                    dependencies=[],\r\n                    required_resources=["navigation", "manipulation"] if parsed_input["intent"] == "delivery" else ["navigation"],\r\n                    estimated_duration=30.0\r\n                )\r\n                self.task_planner.add_task(task)\r\n\r\n            return response\r\n\r\n        elif input_type == "gesture":\r\n            gesture_result = self.human_interface.process_gesture_input(input_data["type"], input_data["data"])\r\n            action = gesture_result["action"]\r\n\r\n            # Convert gesture to appropriate action\r\n            if action == "approach":\r\n                # Create navigation task to approach user\r\n                task = Task(\r\n                    id=str(uuid.uuid4()),\r\n                    name="approach_user",\r\n                    description="Navigate to user location",\r\n                    priority=2,\r\n                    status=TaskStatus.PENDING,\r\n                    dependencies=[],\r\n                    required_resources=["navigation"],\r\n                    estimated_duration=15.0\r\n                )\r\n                self.task_planner.add_task(task)\r\n                return "Approaching you now."\r\n\r\n            return f"Gesture recognized: {action}"\r\n\r\n        return "Input not recognized"\r\n\r\n    def autonomous_decision_cycle(self) -> List[Decision]:\r\n        """Main decision-making cycle"""\r\n        decisions = []\r\n\r\n        # Get available tasks\r\n        available_tasks = self.task_planner.prioritize_tasks(self.current_state)\r\n\r\n        if available_tasks:\r\n            # Make decision about which task to execute\r\n            context = {\r\n                \'available_tasks\': available_tasks,\r\n                \'robot_state\': self.current_state,\r\n                \'belief_state\': self.decision_maker.uncertainty_model.belief_state\r\n            }\r\n\r\n            decision = self.decision_maker.make_decision(DecisionType.PLANNING, context)\r\n            decisions.append(decision)\r\n\r\n            # Execute selected task\r\n            selected_task_id = decision.selected_option.get(\'task_id\')\r\n            if selected_task_id:\r\n                task = next((t for t in available_tasks if t.id == selected_task_id), None)\r\n                if task:\r\n                    success = self.task_planner.execute_task(task, self.current_state)\r\n                    if not success:\r\n                        print(f"Task {task.name} failed")\r\n\r\n        # Make other autonomous decisions as needed\r\n        if self.current_state.battery_level < 0.2:\r\n            # Decision to return to charging station\r\n            context = {\r\n                \'battery_level\': self.current_state.battery_level,\r\n                \'charging_station_pos\': np.array([0, 0, 0])\r\n            }\r\n            decision = self.decision_maker.make_decision(DecisionType.ACTION, context)\r\n            decisions.append(decision)\r\n\r\n        return decisions\r\n\r\n    def get_system_status(self) -> Dict[str, Any]:\r\n        """Get current system status"""\r\n        return {\r\n            \'autonomy_level\': self.autonomy_level,\r\n            \'battery_level\': self.current_state.battery_level,\r\n            \'active_tasks\': len([t for t in self.task_planner.tasks if t.status == TaskStatus.IN_PROGRESS]),\r\n            \'pending_tasks\': len([t for t in self.task_planner.tasks if t.status == TaskStatus.PENDING]),\r\n            \'completed_tasks\': len(self.task_planner.completed_tasks),\r\n            \'failed_tasks\': len(self.task_planner.failed_tasks),\r\n            \'decision_count\': len(self.decision_maker.decision_history),\r\n            \'safety_monitoring\': self.safety_monitoring\r\n        }\r\n\r\ndef demonstrate_autonomy_system():\r\n    """Demonstrate autonomous decision making concepts"""\r\n    print("Decision Making and Autonomy - Chapter 12")\r\n    print("=" * 50)\r\n\r\n    # Initialize autonomy system\r\n    autonomy_system = AutonomySystem()\r\n\r\n    print("1. Task Planning Demo:")\r\n\r\n    # Create some sample tasks\r\n    tasks = [\r\n        Task(\r\n            id=str(uuid.uuid4()),\r\n            name="navigation_to_kitchen",\r\n            description="Navigate to kitchen area",\r\n            priority=2,\r\n            status=TaskStatus.PENDING,\r\n            dependencies=[],\r\n            required_resources=["navigation"],\r\n            estimated_duration=20.0\r\n        ),\r\n        Task(\r\n            id=str(uuid.uuid4()),\r\n            name="object_identification",\r\n            description="Identify objects in kitchen",\r\n            priority=3,\r\n            status=TaskStatus.PENDING,\r\n            dependencies=["navigation_to_kitchen"],\r\n            required_resources=["vision"],\r\n            estimated_duration=10.0\r\n        ),\r\n        Task(\r\n            id=str(uuid.uuid4()),\r\n            name="grasp_object",\r\n            description="Grasp identified object",\r\n            priority=4,\r\n            status=TaskStatus.PENDING,\r\n            dependencies=["object_identification"],\r\n            required_resources=["manipulation"],\r\n            estimated_duration=15.0\r\n        )\r\n    ]\r\n\r\n    for task in tasks:\r\n        autonomy_system.task_planner.add_task(task)\r\n\r\n    print(f"   - Added {len(tasks)} tasks to planner")\r\n    print(f"   - Available tasks: {[t.name for t in autonomy_system.task_planner.get_available_tasks()]}")\r\n\r\n    print("\\n2. Human-Robot Interaction Demo:")\r\n\r\n    # Simulate user input\r\n    speech_input = "Can you bring me a cup of water from the kitchen?"\r\n    response = autonomy_system.process_user_input("speech", speech_input)\r\n    print(f"   - User: \'{speech_input}\'")\r\n    print(f"   - Robot: \'{response}\'")\r\n\r\n    # Simulate gesture input\r\n    gesture_input = {"type": "wave", "data": {"position": [1, 0, 0]}}\r\n    gesture_response = autonomy_system.process_user_input("gesture", gesture_input)\r\n    print(f"   - Gesture detected: wave")\r\n    print(f"   - Robot response: \'{gesture_response}\'")\r\n\r\n    print("\\n3. Autonomous Decision Making Demo:")\r\n\r\n    # Simulate robot state updates\r\n    new_state = RobotState(\r\n        position=np.array([1.0, 0.5, 0.0]),\r\n        orientation=np.array([0.0, 0.0, 0.1]),\r\n        battery_level=0.75,\r\n        joint_positions=np.random.random(20) * 0.5,\r\n        joint_velocities=np.random.random(20) * 0.1,\r\n        gripper_state=0.0,\r\n        timestamp=time.time()\r\n    )\r\n    autonomy_system.update_state(new_state)\r\n\r\n    # Run autonomous decision cycle\r\n    decisions = autonomy_system.autonomous_decision_cycle()\r\n    print(f"   - Made {len(decisions)} autonomous decisions:")\r\n    for i, decision in enumerate(decisions[:2]):  # Show first 2 decisions\r\n        print(f"     Decision {i+1}: {decision.decision_type.value} - {decision.selected_option.get(\'action\', \'N/A\')}")\r\n\r\n    print("\\n4. Uncertainty Reasoning Demo:")\r\n\r\n    # Simulate sensor data with uncertainty\r\n    sensor_data = {\r\n        \'position\': [1.05, 0.48, 0.02],  # Noisy position measurement\r\n        \'battery_level\': 0.74  # Slightly different from reported\r\n    }\r\n\r\n    updated_beliefs = autonomy_system.decision_maker.uncertainty_model.update_belief(sensor_data)\r\n    print(f"   - Updated beliefs: position={updated_beliefs.get(\'position\', \'N/A\')}")\r\n    print(f"   - Position uncertainty: {updated_beliefs.get(\'position_uncertainty\', \'N/A\')}")\r\n\r\n    # Sample from belief distribution\r\n    position_samples = autonomy_system.decision_maker.uncertainty_model.sample_from_belief(\'position\', 5)\r\n    print(f"   - Sampled positions: {position_samples[:2]}...")  # Show first 2 samples\r\n\r\n    print("\\n5. System Status:")\r\n    status = autonomy_system.get_system_status()\r\n    for key, value in status.items():\r\n        print(f"   - {key.replace(\'_\', \' \').title()}: {value}")\r\n\r\n    print("\\n6. Ethical Decision Making:")\r\n\r\n    # Demonstrate ethical constraint checking\r\n    test_decision = Decision(\r\n        id=str(uuid.uuid4()),\r\n        decision_type=DecisionType.ACTION,\r\n        context={\'test\': True},\r\n        options=[{\'action\': \'move_toward_object\'}],\r\n        selected_option={\'action\': \'move_toward_object\'},\r\n        confidence=0.9,\r\n        timestamp=time.time(),\r\n        rationale="Test decision"\r\n    )\r\n\r\n    ethical_check = autonomy_system.decision_maker._check_ethical_constraints(test_decision)\r\n    print(f"   - Ethical constraint check passed: {ethical_check}")\r\n\r\n    print("\\n7. Autonomy Levels:")\r\n    autonomy_levels = {\r\n        0: "No autonomy - fully human controlled",\r\n        1: "Low autonomy - human gives simple commands",\r\n        2: "Limited autonomy - robot handles basic tasks",\r\n        3: "Conditional autonomy - robot handles most tasks with human oversight",\r\n        4: "High autonomy - robot handles complex tasks independently",\r\n        5: "Full autonomy - robot handles all tasks without human intervention"\r\n    }\r\n\r\n    current_level = autonomy_system.autonomy_level\r\n    print(f"   - Current autonomy level: {current_level}")\r\n    print(f"   - Description: {autonomy_levels[current_level]}")\r\n\r\n    # Performance metrics\r\n    print("\\n8. Performance Analysis:")\r\n    print(f"   - Decision making speed: {len(decisions)/0.1:.1f} decisions/second (simulated)")\r\n    print(f"   - Task success rate: {len(autonomy_system.task_planner.completed_tasks)}/{len(autonomy_system.task_planner.completed_tasks) + len(autonomy_system.task_planner.failed_tasks) or 1:.1%}")\r\n    print(f"   - Current battery level: {autonomy_system.current_state.battery_level:.1%}")\r\n\r\n    return {\r\n        \'decisions_made\': len(decisions),\r\n        \'tasks_completed\': len(autonomy_system.task_planner.completed_tasks),\r\n        \'current_battery\': autonomy_system.current_state.battery_level,\r\n        \'system_status\': status\r\n    }\r\n\r\ndef analyze_decision_performance(results: Dict) -> Dict:\r\n    """Analyze decision making performance metrics"""\r\n    analysis = {\r\n        \'decision_quality\': {\r\n            \'decisions_per_cycle\': results[\'decisions_made\'],\r\n            \'decision_diversity\': \'N/A\'  # Would need more detailed tracking\r\n        },\r\n        \'task_performance\': {\r\n            \'tasks_completed\': results[\'tasks_completed\'],\r\n            \'efficiency\': results[\'tasks_completed\'] / max(results[\'decisions_made\'], 1)\r\n        },\r\n        \'system_health\': {\r\n            \'battery_level\': results[\'current_battery\'],\r\n            \'system_stability\': \'Good\'  # Would be determined by detailed monitoring\r\n        },\r\n        \'interaction_quality\': {\r\n            \'responses_generated\': 2,  # From the demo\r\n            \'understanding_accuracy\': \'N/A\'  # Would require evaluation\r\n        }\r\n    }\r\n\r\n    return analysis\r\n\r\ndef discuss_ethical_considerations():\r\n    """Discuss ethical considerations in autonomous robotics"""\r\n    print(f"\\n9. Ethical Considerations in Autonomous Robotics:")\r\n\r\n    ethical_principles = [\r\n        ("Beneficence", "Act in ways that benefit humans and promote wellbeing"),\r\n        ("Non-maleficence", "Avoid causing harm to humans or property"),\r\n        ("Autonomy", "Respect human autonomy and decision-making"),\r\n        ("Justice", "Ensure fair treatment regardless of user characteristics"),\r\n        ("Explainability", "Provide clear explanations for robot decisions"),\r\n        ("Privacy", "Protect user data and maintain confidentiality")\r\n    ]\r\n\r\n    print("\\n   Core Ethical Principles:")\r\n    for principle, description in ethical_principles:\r\n        print(f"     - {principle}: {description}")\r\n\r\n    implementation_strategies = [\r\n        "Value-sensitive design: Incorporate ethical values during system design",\r\n        "Fail-safe mechanisms: Ensure safe behavior when systems fail",\r\n        "Human oversight: Maintain human control over critical decisions",\r\n        "Transparency: Make system capabilities and limitations clear",\r\n        "Consent mechanisms: Obtain permission for data collection and use"\r\n    ]\r\n\r\n    print("\\n   Implementation Strategies:")\r\n    for strategy in implementation_strategies:\r\n        print(f"     - {strategy}")\r\n\r\n    challenges = [\r\n        "Balancing autonomy with safety",\r\n        "Handling conflicting ethical principles",\r\n        "Ensuring fairness across diverse populations",\r\n        "Maintaining privacy while providing personalized service",\r\n        "Dealing with unpredictable human behavior"\r\n    ]\r\n\r\n    print("\\n   Key Challenges:")\r\n    for challenge in challenges:\r\n        print(f"     - {challenge}")\r\n\r\nif __name__ == "__main__":\r\n    import time  # Import time for timestamp operations\r\n\r\n    # Run the demonstration\r\n    results = demonstrate_autonomy_system()\r\n\r\n    # Analyze performance\r\n    performance_analysis = analyze_decision_performance(results)\r\n\r\n    print(f"\\n10. Performance Analysis Summary:")\r\n    for category, metrics in performance_analysis.items():\r\n        print(f"\\n   {category.replace(\'_\', \' \').title()}:")\r\n        for metric, value in metrics.items():\r\n            print(f"     - {metric.replace(\'_\', \' \')}: {value}")\r\n\r\n    # Discuss ethical considerations\r\n    discuss_ethical_considerations()\r\n\r\n    print(f"\\n11. Key Takeaways:")\r\n    print("    - Autonomous systems require sophisticated planning and reasoning")\r\n    print("    - Uncertainty management is crucial for real-world operation")\r\n    print("    - Human-robot interaction needs to be natural and intuitive")\r\n    print("    - Ethical considerations must be built into system design")\r\n    print("    - Safety and reliability are paramount in autonomous systems")\r\n\r\n    print(f"\\nDecision Making and Autonomy - Chapter 12 Complete!")\n'})}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Implement a task planner that can handle temporal and resource constraints for a multi-step manipulation task."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Design a decision-making system that incorporates ethical constraints for a service robot operating in a hospital environment."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Create a human-robot interaction system that can adapt its communication style based on user preferences and context."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary-1",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter provided a comprehensive overview of decision-making and autonomy systems for humanoid robots, covering task planning, reasoning under uncertainty, human-robot interaction, and ethical considerations. We explored mathematical foundations, practical implementations, and the challenges of creating truly autonomous robotic systems. The concepts and code examples presented will help in developing intelligent robots that can operate independently while maintaining safety and ethical standards."})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);