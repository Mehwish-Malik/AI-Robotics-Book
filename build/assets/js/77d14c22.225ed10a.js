"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[123],{895:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var t=r(4848),o=r(8453);const s={sidebar_position:3},l="Chapter 9: Balance and Stability Control",i={id:"modules/module-3-control/chapter-9-balance",title:"Chapter 9: Balance and Stability Control",description:"Summary",source:"@site/docs/modules/module-3-control/chapter-9-balance.md",sourceDirName:"modules/module-3-control",slug:"/modules/module-3-control/chapter-9-balance",permalink:"/docs/modules/module-3-control/chapter-9-balance",draft:!1,unlisted:!1,editUrl:"https://github.com/Mehwish-Malik/AI-Robotics-Book.git/docs/modules/module-3-control/chapter-9-balance.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Chapter 8: Locomotion and Gait Control",permalink:"/docs/modules/module-3-control/chapter-8-locomotion"},next:{title:"Chapter 10: Computer Vision and Perception",permalink:"/docs/modules/module-4-ai/chapter-10-perception"}},a={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Introduction to Balance Control",id:"introduction-to-balance-control",level:2},{value:"Balance Fundamentals",id:"balance-fundamentals",level:3},{value:"Balance Control Challenges",id:"balance-control-challenges",level:3},{value:"Feedback Control Systems",id:"feedback-control-systems",level:2},{value:"Proportional-Integral-Derivative (PID) Control",id:"proportional-integral-derivative-pid-control",level:3},{value:"State Feedback Control",id:"state-feedback-control",level:3},{value:"Adaptive Control",id:"adaptive-control",level:3},{value:"Feedforward Control Strategies",id:"feedforward-control-strategies",level:2},{value:"Preview Control",id:"preview-control",level:3},{value:"Feedforward Compensation",id:"feedforward-compensation",level:3},{value:"Trajectory-Based Feedforward",id:"trajectory-based-feedforward",level:3},{value:"Disturbance Rejection",id:"disturbance-rejection",level:2},{value:"Types of Disturbances",id:"types-of-disturbances",level:3},{value:"Disturbance Observer",id:"disturbance-observer",level:3},{value:"Robust Control",id:"robust-control",level:3},{value:"Recovery from Perturbations",id:"recovery-from-perturbations",level:2},{value:"Balance Recovery Strategies",id:"balance-recovery-strategies",level:3},{value:"Recovery Phase Classification",id:"recovery-phase-classification",level:3},{value:"Multi-Step Recovery",id:"multi-step-recovery",level:3},{value:"Multi-Level Control Hierarchy",id:"multi-level-control-hierarchy",level:2},{value:"High-Level Balance Control",id:"high-level-balance-control",level:3},{value:"Mid-Level Balance Control",id:"mid-level-balance-control",level:3},{value:"Low-Level Balance Control",id:"low-level-balance-control",level:3},{value:"Technical Depth: Mathematical Foundations",id:"technical-depth-mathematical-foundations",level:2},{value:"Linear Inverted Pendulum Model",id:"linear-inverted-pendulum-model",level:3},{value:"State-Space Representation",id:"state-space-representation",level:3},{value:"Stability Analysis",id:"stability-analysis",level:3},{value:"Optimal Control Formulation",id:"optimal-control-formulation",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Figure List",id:"figure-list",level:2},{value:"Code Example: Balance Control Implementation",id:"code-example-balance-control-implementation",level:2}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"chapter-9-balance-and-stability-control",children:"Chapter 9: Balance and Stability Control"}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter examines the critical systems that enable humanoid robots to maintain stability and balance during static and dynamic conditions. We'll explore feedback and feedforward control strategies, disturbance rejection techniques, and recovery mechanisms that allow robots to maintain equilibrium in the face of internal and external disturbances. Understanding balance control is fundamental to creating safe and capable humanoid robots."}),"\n",(0,t.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the principles of static and dynamic balance control"}),"\n",(0,t.jsx)(n.li,{children:"Analyze different feedback and feedforward control strategies"}),"\n",(0,t.jsx)(n.li,{children:"Design controllers for disturbance rejection and recovery"}),"\n",(0,t.jsx)(n.li,{children:"Implement multi-level control hierarchies for balance"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate balance performance and stability margins"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Static Balance"}),": Stability without motion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Balance"}),": Stability maintained through active control during motion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback Control"}),": Control based on measured system state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedforward Control"}),": Control based on predicted or desired behavior"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Disturbance Rejection"}),": Ability to maintain balance despite external forces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery Strategies"}),": Methods to regain balance after disturbances"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stability Margins"}),": Quantitative measures of balance robustness"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Control Hierarchies"}),": Multi-level control structures for balance"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-balance-control",children:"Introduction to Balance Control"}),"\n",(0,t.jsx)(n.p,{children:"Balance control in humanoid robots is a complex task that involves maintaining the center of mass within the support polygon while executing tasks. Unlike static structures, humanoid robots must actively control their balance through coordinated joint movements and sophisticated control algorithms."}),"\n",(0,t.jsx)(n.h3,{id:"balance-fundamentals",children:"Balance Fundamentals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Support Polygon"}),": The convex hull of all contact points with the ground"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Center of Mass (CoM)"}),": The point where the total mass can be considered concentrated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),": The point where the moment of ground reaction force equals zero"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capture Point"}),": The point where the robot must step to stop"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"balance-control-challenges",children:"Balance Control Challenges"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"High-Dimensional Systems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Underactuation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Real-time Requirements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Uncertainty"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Safety"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"feedback-control-systems",children:"Feedback Control Systems"}),"\n",(0,t.jsx)(n.h3,{id:"proportional-integral-derivative-pid-control",children:"Proportional-Integral-Derivative (PID) Control"}),"\n",(0,t.jsx)(n.p,{children:"PID controllers are fundamental in balance control:"}),"\n",(0,t.jsx)(n.p,{children:"u(t) = K_p * e(t) + K_i * \u222be(t)dt + K_d * de(t)/dt"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"u(t) = control output"}),"\n",(0,t.jsx)(n.li,{children:"e(t) = error (desired - actual)"}),"\n",(0,t.jsx)(n.li,{children:"K_p, K_i, K_d = controller gains"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Position-based PID"}),": Controls joint positions relative to desired values",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Force-based PID"}),": Controls contact forces relative to desired values",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"ZMP-based PID"}),": Controls ZMP position relative to desired values"]}),"\n",(0,t.jsx)(n.h3,{id:"state-feedback-control",children:"State Feedback Control"}),"\n",(0,t.jsx)(n.p,{children:"State feedback uses the full system state for control:"}),"\n",(0,t.jsx)(n.p,{children:"u = -K * x + r"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"u = control input"}),"\n",(0,t.jsx)(n.li,{children:"K = feedback gain matrix"}),"\n",(0,t.jsx)(n.li,{children:"x = state vector"}),"\n",(0,t.jsx)(n.li,{children:"r = reference input"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Linear Quadratic Regulator (LQR)"}),": Optimizes control for linear systems\nK = R\u207b\xb9 * B\u1d40 * P"]}),"\n",(0,t.jsx)(n.p,{children:"vbnet\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where P is the solution to the algebraic Riccati equation."}),"\n",(0,t.jsx)(n.h3,{id:"adaptive-control",children:"Adaptive Control"}),"\n",(0,t.jsx)(n.p,{children:"Adaptive controllers adjust parameters based on system behavior:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Model Reference Adaptive Control (MRAC)"}),":\n\u03b8\u0307 = -\u0393 * \u03c6 * e"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u03b8 = parameter vector"}),"\n",(0,t.jsx)(n.li,{children:"\u0393 = adaptation gain"}),"\n",(0,t.jsx)(n.li,{children:"\u03c6 = regressor vector"}),"\n",(0,t.jsx)(n.li,{children:"e = tracking error"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Self-Tuning Regulators"}),": Adjust controller parameters based on system identification."]}),"\n",(0,t.jsx)(n.h2,{id:"feedforward-control-strategies",children:"Feedforward Control Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"preview-control",children:"Preview Control"}),"\n",(0,t.jsx)(n.p,{children:"Preview control uses future reference trajectory to compute current control:"}),"\n",(0,t.jsx)(n.p,{children:"u(k) = -Kx(k) - K_f * \u03a3(i=0 to N-1) G_f(i) * r(k+i)"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"N = preview horizon"}),"\n",(0,t.jsx)(n.li,{children:"r = reference trajectory"}),"\n",(0,t.jsx)(n.li,{children:"K_f, G_f = preview control gains"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"feedforward-compensation",children:"Feedforward Compensation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gravity Compensation"}),": Counteract gravitational forces\n\u03c4_gravity = G(q)"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Coriolis Compensation"}),": Counteract velocity-dependent forces\n\u03c4_coriolis = C(q, q\u0307)q\u0307"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disturbance Feedforward"}),": Predict and counteract known disturbances\n\u03c4_disturbance = F_external"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.h3,{id:"trajectory-based-feedforward",children:"Trajectory-Based Feedforward"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Computed Torque Control"}),": Linearize system dynamics\n\u03c4 = M(q) * (q\u0308_d + K_v * (q\u0307_d - q\u0307) + K_p * (q_d - q))"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.h2,{id:"disturbance-rejection",children:"Disturbance Rejection"}),"\n",(0,t.jsx)(n.h3,{id:"types-of-disturbances",children:"Types of Disturbances"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impulsive Disturbances"}),": Sudden impacts or pushes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent Disturbances"}),": Continuous external forces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Internal Disturbances"}),": Actuator failures, sensor noise"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environmental Disturbances"}),": Wind, uneven terrain, slippery surfaces"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"disturbance-observer",children:"Disturbance Observer"}),"\n",(0,t.jsx)(n.p,{children:"Estimate disturbances and compensate for them:"}),"\n",(0,t.jsx)(n.p,{children:"d\u0302 = L(s) * (y - \u0177)"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"d\u0302 = estimated disturbance"}),"\n",(0,t.jsx)(n.li,{children:"L(s) = observer gain"}),"\n",(0,t.jsx)(n.li,{children:"y = measured output"}),"\n",(0,t.jsx)(n.li,{children:"\u0177 = estimated output"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"robust-control",children:"Robust Control"}),"\n",(0,t.jsx)(n.p,{children:"Design controllers that maintain performance despite uncertainties:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"H-infinity Control"}),": Minimize worst-case performance\n||T_",wd,"||_\u221e < \u03b3"]}),"\n",(0,t.jsx)(n.p,{children:"pgsql\nCopy code"}),"\n",(0,t.jsxs)(n.p,{children:["Where T_",wd," is the transfer function from disturbance to output."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mu-Synthesis"}),": Handle structured uncertainties\n\u03bc_\u0394(T) < 1"]}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.h2,{id:"recovery-from-perturbations",children:"Recovery from Perturbations"}),"\n",(0,t.jsx)(n.h3,{id:"balance-recovery-strategies",children:"Balance Recovery Strategies"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Ankle Strategy"}),": Use ankle torques for small disturbances",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Hip Strategy"}),": Use hip torques for medium disturbances",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Stepping Strategy"}),": Take a step to expand support base",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Suspension Strategy"}),": Move CoM to maintain balance"]}),"\n",(0,t.jsx)(n.h3,{id:"recovery-phase-classification",children:"Recovery Phase Classification"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stability Boundary"}),": Threshold where different strategies become necessary"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery Strategy Selection"}),": Choose strategy based on disturbance magnitude"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CoM State"}),": Position and velocity of center of mass"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Support State"}),": Current support polygon configuration"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"multi-step-recovery",children:"Multi-Step Recovery"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initial Response"}),": Immediate reflexive action"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Strategy Selection"}),": Choose appropriate recovery strategy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution"}),": Implement recovery action"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verification"}),": Confirm balance recovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Return to Normal"}),": Resume normal behavior"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"multi-level-control-hierarchy",children:"Multi-Level Control Hierarchy"}),"\n",(0,t.jsx)(n.h3,{id:"high-level-balance-control",children:"High-Level Balance Control"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Balance Planning"}),": Step planning, CoM trajectory, gait selection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task Prioritization"}),": Balance vs task execution, safety vs efficiency"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mid-level-balance-control",children:"Mid-Level Balance Control"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ZMP/Capture Point Control"}),": Reference trajectory tracking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Whole-Body Control"}),": Coordinate all degrees of freedom"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"low-level-balance-control",children:"Low-Level Balance Control"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Joint-Level Control"}),": PID, current control, safety limits"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Processing"}),": IMU, force, and vision feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"technical-depth-mathematical-foundations",children:"Technical Depth: Mathematical Foundations"}),"\n",(0,t.jsx)(n.h3,{id:"linear-inverted-pendulum-model",children:"Linear Inverted Pendulum Model"}),"\n",(0,t.jsx)(n.p,{children:"\u1e8d_com = \u03c9\xb2 * (x_com - x_zmp)\n\xff_com = \u03c9\xb2 * (y_com - y_zmp)"}),"\n",(0,t.jsx)(n.p,{children:"powershell\nCopy code"}),"\n",(0,t.jsx)(n.p,{children:"Where \u03c9\xb2 = g/h (natural frequency)."}),"\n",(0,t.jsx)(n.h3,{id:"state-space-representation",children:"State-Space Representation"}),"\n",(0,t.jsx)(n.p,{children:"\u1e8b = Ax + Bu + Bd\ny = Cx + Du"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.h3,{id:"stability-analysis",children:"Stability Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Lyapunov Stability"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"BIBO Stability"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Routh-Hurwitz Criterion"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"optimal-control-formulation",children:"Optimal Control Formulation"}),"\n",(0,t.jsx)(n.p,{children:"J = \u222b[x\u1d40Qx + u\u1d40Ru] dt\n\u1e8b = Ax + Bu\nu = -R\u207b\xb9B\u1d40Px"}),"\n",(0,t.jsx)(n.p,{children:"markdown\nCopy code"}),"\n",(0,t.jsx)(n.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Standing Balance"}),": Quiet vs challenged stance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Walking Balance"}),": Gait integration, ZMP trajectory"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Manipulation Balance"}),": Dual-task performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery Scenarios"}),": Push and trip recovery"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Control Complexity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Real-time Performance"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Modeling Uncertainty"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Safety vs Performance"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"figure-list",children:"Figure List"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Balance control hierarchy diagram"}),"\n",(0,t.jsx)(n.li,{children:"Feedback vs feedforward control comparison"}),"\n",(0,t.jsx)(n.li,{children:"Disturbance rejection mechanisms"}),"\n",(0,t.jsx)(n.li,{children:"Recovery strategy selection tree"}),"\n",(0,t.jsx)(n.li,{children:"Stability margin visualization"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-example-balance-control-implementation",children:"Code Example: Balance Control Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple, Optional, Dict\nfrom dataclasses import dataclass\nimport matplotlib.pyplot as plt\nfrom scipy.linalg import solve_continuous_are, solve\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict\nfrom dataclasses import dataclass\nimport matplotlib.pyplot as plt\nfrom scipy.linalg import solve_continuous_are, solve\n\n@dataclass\nclass BalanceState:\n    """Current state for balance control"""\n    com_pos: np.ndarray      # Center of mass position [x, y, z]\n    com_vel: np.ndarray      # Center of mass velocity [vx, vy, vz]\n    com_acc: np.ndarray      # Center of mass acceleration\n    zmp_pos: np.ndarray      # Zero Moment Point [x, y]\n    capture_point: np.ndarray # Capture Point [x, y]\n    support_polygon: np.ndarray  # Support polygon vertices\n    angular_momentum: np.ndarray  # Angular momentum [Lx, Ly, Lz]\n    timestamp: float\n\n@dataclass\nclass BalanceControlParams:\n    """Parameters for balance control"""\n    kp_com: float = 10.0\n    ki_com: float = 1.0\n    kd_com: float = 2.0\n    kp_zmp: float = 15.0\n    kd_zmp: float = 5.0\n    capture_threshold: float = 0.15\n    max_step_size: float = 0.3\n    max_torque: float = 50.0\n    max_angular_velocity: float = 1.0\n\nclass BalanceController:\n    def __init__(self, com_height: float = 0.8):\n        self.com_height = com_height\n        self.gravity = 9.81\n        self.omega = np.sqrt(self.gravity / self.com_height)\n        self.state = BalanceState(\n            com_pos=np.zeros(3),\n            com_vel=np.zeros(3),\n            com_acc=np.zeros(3),\n            zmp_pos=np.zeros(2),\n            capture_point=np.zeros(2),\n            support_polygon=np.array([[0.1, 0.1], [-0.1, 0.1], [-0.1, -0.1], [0.1, -0.1]]),\n            angular_momentum=np.zeros(3),\n            timestamp=0.0\n        )\n        self.params = BalanceControlParams()\n        self.integral_error = np.zeros(2)\n        self.previous_error = np.zeros(2)\n        self.current_strategy = "ankle"\n        self.recovery_active = False\n        self.recovery_start_time = 0.0\n\n    def point_in_polygon(self, point: np.ndarray, polygon: np.ndarray) -> bool:\n        """Check if a point is inside a polygon using ray casting"""\n        x, y = point\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def distance_point_to_segment(self, point: np.ndarray, seg_start: np.ndarray, seg_end: np.ndarray) -> float:\n        """Distance from point to line segment"""\n        v = point - seg_start\n        s = seg_end - seg_start\n        proj_len = np.dot(v, s) / np.dot(s, s)\n        if proj_len < 0:\n            return np.linalg.norm(point - seg_start)\n        elif proj_len > 1:\n            return np.linalg.norm(point - seg_end)\n        else:\n            closest = seg_start + proj_len * s\n            return np.linalg.norm(point - closest)\n\n    def distance_to_polygon(self, point: np.ndarray, polygon: np.ndarray) -> float:\n        """Minimum distance from point to polygon boundary"""\n        return min(self.distance_point_to_segment(point, polygon[i], polygon[(i+1)%len(polygon)]) for i in range(len(polygon)))\n\n    def select_balance_strategy(self) -> str:\n        """Select strategy based on CoM/ZMP state"""\n        zmp_distance = self.distance_to_polygon(self.state.zmp_pos, self.state.support_polygon)\n        capture_distance = self.distance_to_polygon(self.state.capture_point, self.state.support_polygon)\n        if capture_distance > self.params.capture_threshold:\n            return "stepping"\n        elif capture_distance > 0.08:\n            return "hip"\n        elif zmp_distance > 0.05:\n            return "ankle"\n        else:\n            return "ankle"\n\n    def compute_ankle_strategy(self, dt: float) -> np.ndarray:\n        """Compute ankle strategy control"""\n        desired_com = np.array([0.0, 0.0, self.com_height])\n        pos_error = desired_com[:2] - self.state.com_pos[:2]\n        self.integral_error += pos_error * dt\n        derivative_error = (pos_error - self.previous_error)/dt if dt>0 else np.zeros(2)\n        control_output = self.params.kp_com*pos_error + self.params.ki_com*self.integral_error + self.params.kd_com*derivative_error\n        self.previous_error = pos_error.copy()\n        return control_output\n\n    def compute_hip_strategy(self, dt: float) -> np.ndarray:\n        """Compute hip strategy control"""\n        desired_zmp = np.array([0.0, 0.0])\n        zmp_error = desired_zmp - self.state.zmp_pos\n        derivative_zmp = (zmp_error - self.previous_error)/dt if dt>0 else np.zeros(2)\n        control_output = self.params.kp_zmp*zmp_error + self.params.kd_zmp*derivative_zmp\n        self.previous_error = zmp_error.copy()\n        return control_output\n\n    def compute_stepping_strategy(self) -> np.ndarray:\n        """Compute step target"""\n        step_target = self.state.capture_point.copy()\n        step_distance = np.linalg.norm(step_target)\n        if step_distance > self.params.max_step_size:\n            step_target = (step_target/step_distance)*self.params.max_step_size\n        return step_target\n\n    def compute_zmp(self, com_pos: np.ndarray, com_acc: np.ndarray) -> np.ndarray:\n        """Simplified ZMP computation"""\n        return com_pos[:2] - com_acc[:2]/self.omega**2\n\n    def compute_capture_point(self, com_pos: np.ndarray, com_vel: np.ndarray) -> np.ndarray:\n        """Simplified capture point computation"""\n        return com_pos[:2] + com_vel[:2]/self.omega\n\n    def update_support_polygon(self):\n        """Placeholder: normally would update based on foot contacts"""\n        pass\n\n    def update_balance_state(self, com_pos: np.ndarray, com_vel: np.ndarray, com_acc: np.ndarray, dt: float) -> BalanceState:\n        """Update balance state and compute control"""\n        self.state.com_pos = com_pos\n        self.state.com_vel = com_vel\n        self.state.com_acc = com_acc\n        self.state.zmp_pos = self.compute_zmp(com_pos, com_acc)\n        self.state.capture_point = self.compute_capture_point(com_pos, com_vel)\n        self.update_support_polygon()\n        self.current_strategy = self.select_balance_strategy()\n        self.state.timestamp += dt\n        return self.state\n\n    def compute_joint_torques(self, control_output: np.ndarray) -> np.ndarray:\n        """Map control to joint torques"""\n        torques = np.zeros(20)\n        torques[0] = control_output[0]*20\n        torques[1] = control_output[1]*10\n        torques[6] = -control_output[0]*15\n        torques[7] = -control_output[1]*10\n        torques = np.clip(torques, -self.params.max_torque, self.params.max_torque)\n        return torques\n\nclass DisturbanceObserver:\n    """Estimate external disturbances"""\n    def __init__(self, model_uncertainty: float = 0.1):\n        self.model_uncertainty = model_uncertainty\n        self.estimated_disturbance = np.zeros(2)\n        self.disturbance_error = np.zeros(2)\n        self.gain = 1.0\n\n    def update(self, measured_output: np.ndarray, predicted_output: np.ndarray, dt: float) -> np.ndarray:\n        error = measured_output - predicted_output\n        self.disturbance_error += error*dt\n        self.estimated_disturbance = self.gain*error + 0.1*self.disturbance_error\n        self.estimated_disturbance = np.clip(self.estimated_disturbance, -100, 100)\n        return self.estimated_disturbance\n\nclass BalancePerformanceAnalyzer:\n    """Analyze performance"""\n    def __init__(self):\n        self.metrics = {\'stability_margin\': [], \'control_effort\': []}\n\n    def calculate_stability_margin(self, zmp_pos: np.ndarray, support_polygon: np.ndarray) -> float:\n        return min(np.linalg.norm(zmp_pos - vertex) for vertex in support_polygon)\n\n    def calculate_control_effort(self, torques: np.ndarray) -> float:\n        return np.sum(np.abs(torques))\n\n    def add_sample(self, zmp_pos: np.ndarray, support_polygon: np.ndarray, torques: np.ndarray, timestamp: float):\n        self.metrics[\'stability_margin\'].append(self.calculate_stability_margin(zmp_pos, support_polygon))\n        self.metrics[\'control_effort\'].append(self.calculate_control_effort(torques))\n\n    def get_performance_summary(self) -> Dict:\n        return {\n            \'avg_stability_margin\': np.mean(self.metrics[\'stability_margin\']),\n            \'min_stability_margin\': min(self.metrics[\'stability_margin\']),\n            \'avg_control_effort\': np.mean(self.metrics[\'control_effort\']),\n            \'max_control_effort\': max(self.metrics[\'control_effort\']),\n            \'stability_std\': np.std(self.metrics[\'stability_margin\'])\n        }\n\n\nExercises\nImplement a balance controller that switches between ankle and hip strategies based on ZMP position.\n\nDesign a disturbance observer that can estimate external forces applied to a humanoid robot.\n\nCreate a multi-level balance control system with high-level planning and low-level joint control.\n\nSummary\nThis chapter provided a comprehensive overview of balance and stability control for humanoid robots, covering feedback and feedforward control strategies, disturbance rejection techniques, and recovery mechanisms. We explored mathematical models, control algorithms, and multi-level control hierarchies essential for maintaining robot stability. The concepts and implementations presented will help in developing robust balance control systems for humanoid robots that can maintain equilibrium in various conditions and recover from disturbances safely.\n\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var t=r(6540);const o={},s=t.createContext(o);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);