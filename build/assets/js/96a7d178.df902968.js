"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[694],{173:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>_,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var s=n(4848),r=n(8453);const o={sidebar_position:4},a="Simple Locomotion",i={id:"tutorials/basic-control-examples/simple-locomotion",title:"Simple Locomotion",description:"Overview",source:"@site/docs/tutorials/basic-control-examples/simple-locomotion.md",sourceDirName:"tutorials/basic-control-examples",slug:"/tutorials/basic-control-examples/simple-locomotion",permalink:"/docs/tutorials/basic-control-examples/simple-locomotion",draft:!1,unlisted:!1,editUrl:"https://github.com/Mehwish-Malik/AI-Robotics-Book.git/docs/tutorials/basic-control-examples/simple-locomotion.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Locomotion Fundamentals",id:"locomotion-fundamentals",level:2},{value:"Gait Cycle Phases",id:"gait-cycle-phases",level:3},{value:"Inverted Pendulum Walking Model",id:"inverted-pendulum-walking-model",level:2},{value:"ZMP-Based Walking Controller",id:"zmp-based-walking-controller",level:2},{value:"Simple Stepping Pattern",id:"simple-stepping-pattern",level:2},{value:"Walk Pattern Generator",id:"walk-pattern-generator",level:2},{value:"Practical Walking Controller",id:"practical-walking-controller",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercises",id:"exercises",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"simple-locomotion",children:"Simple Locomotion"}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"Locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control systems to maintain balance while moving. This tutorial covers fundamental locomotion concepts including gait generation, ZMP-based walking, and basic stepping patterns."}),"\n",(0,s.jsx)(t.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(t.p,{children:"By the end of this tutorial, you will be able to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Understand the basics of bipedal locomotion"}),"\n",(0,s.jsx)(t.li,{children:"Generate simple walking patterns"}),"\n",(0,s.jsx)(t.li,{children:"Implement ZMP-based walking control"}),"\n",(0,s.jsx)(t.li,{children:"Create basic stepping and balance recovery patterns"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"locomotion-fundamentals",children:"Locomotion Fundamentals"}),"\n",(0,s.jsx)(t.h3,{id:"gait-cycle-phases",children:"Gait Cycle Phases"}),"\n",(0,s.jsx)(t.p,{children:"Bipedal locomotion consists of several phases:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stance Phase"}),": When the foot is in contact with the ground"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Swing Phase"}),": When the foot is off the ground moving forward"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Double Support Phase"}),": When both feet are in contact"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Single Support Phase"}),": When only one foot is in contact"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\nclass GaitPhase:\n    """Represents a phase in the gait cycle"""\n    def __init__(self, name, start_time, end_time, support_leg):\n        self.name = name\n        self.start_time = start_time\n        self.end_time = end_time\n        self.support_leg = support_leg  # \'left\', \'right\', or \'both\'\n        self.duration = end_time - start_time\n\nclass GaitGenerator:\n    """Generate basic walking gaits"""\n    def __init__(self, step_length=0.3, step_width=0.2, step_time=0.8):\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_time = step_time\n        self.gait_phases = self._generate_gait_phases()\n\n    def _generate_gait_phases(self):\n        """Generate the phases of a basic walking gait"""\n        phases = []\n\n        # Single support phase - left foot supports, right foot swings\n        phases.append(GaitPhase("Left Support", 0, self.step_time/2, "left"))\n\n        # Double support phase - both feet on ground\n        phases.append(GaitPhase("Double Support", self.step_time/2, self.step_time/2 + 0.05, "both"))\n\n        # Single support phase - right foot supports, left foot swings\n        phases.append(GaitPhase("Right Support", self.step_time/2 + 0.05, self.step_time, "right"))\n\n        return phases\n\n    def get_current_phase(self, time):\n        """Get the current gait phase based on time"""\n        cycle_time = time % self.step_time\n        for phase in self.gait_phases:\n            if phase.start_time <= cycle_time <= phase.end_time:\n                return phase\n        return self.gait_phases[-1]  # Return last phase if none match\n\n    def generate_foot_trajectory(self, start_pos, step_num, side="left"):\n        """Generate foot trajectory for a step"""\n        # Define key points in the foot trajectory\n        lift_height = 0.05  # 5cm lift\n\n        # Start position\n        start_x = start_pos[0] + (step_num * self.step_length)\n        start_y = start_pos[1] + (self.step_width if side == "right" else -self.step_width)\n\n        # End position (next step)\n        end_x = start_x + self.step_length\n        end_y = start_pos[1] + (-self.step_width if side == "right" else self.step_width)\n\n        # Generate trajectory points\n        t = np.linspace(0, 1, 50)\n\n        # X trajectory (smooth interpolation)\n        x_traj = start_x + (end_x - start_x) * t\n\n        # Y trajectory (return to center line)\n        y_traj = start_y + (end_y - start_y) * t\n\n        # Z trajectory (parabolic lift and place)\n        z_lift = 4 * lift_height * t * (1 - t)  # Parabolic curve\n\n        return np.column_stack([x_traj, y_traj, z_lift])\n\n# Example usage\ngait_gen = GaitGenerator(step_length=0.3, step_width=0.15, step_time=0.8)\ncurrent_phase = gait_gen.get_current_phase(0.4)\nprint(f"Current phase at t=0.4s: {current_phase.name}, support: {current_phase.support_leg}")\n'})}),"\n",(0,s.jsx)(t.h2,{id:"inverted-pendulum-walking-model",children:"Inverted Pendulum Walking Model"}),"\n",(0,s.jsx)(t.p,{children:"The linear inverted pendulum is a fundamental model for walking:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class LinearInvertedPendulum:\n    """Linear inverted pendulum model for walking"""\n    def __init__(self, height=0.8, gravity=9.81):\n        self.height = height\n        self.gravity = gravity\n        self.omega = np.sqrt(gravity / height)\n\n    def compute_com_trajectory(self, zmp_trajectory, dt=0.005):\n        """Compute CoM trajectory from ZMP reference"""\n        n_steps = len(zmp_trajectory)\n        com_trajectory = np.zeros((n_steps, 3))\n        com_velocity = np.zeros((n_steps, 3))\n\n        # Initial conditions\n        com_trajectory[0] = [0, 0, self.height]\n        com_velocity[0] = [0, 0, 0]\n\n        # Integrate inverted pendulum dynamics\n        for i in range(1, n_steps):\n            # \u1e8d = \u03c9\xb2 * (x - zmp)\n            com_acc = self.omega**2 * (com_trajectory[i-1, :2] - zmp_trajectory[i])\n            com_acc_full = np.append(com_acc, [0])  # No vertical acceleration\n\n            # Update velocity and position\n            com_velocity[i] = com_velocity[i-1] + com_acc_full * dt\n            com_trajectory[i] = com_trajectory[i-1] + com_velocity[i] * dt + 0.5 * com_acc_full * dt**2\n\n            # Keep constant height\n            com_trajectory[i, 2] = self.height\n\n        return com_trajectory, com_velocity\n\n    def compute_zmp_from_com(self, com_pos, com_acc):\n        """Compute ZMP from CoM state"""\n        zmp_x = com_pos[0] - (com_acc[0] * self.height / self.gravity)\n        zmp_y = com_pos[1] - (com_acc[1] * self.height / self.gravity)\n        return np.array([zmp_x, zmp_y])\n'})}),"\n",(0,s.jsx)(t.h2,{id:"zmp-based-walking-controller",children:"ZMP-Based Walking Controller"}),"\n",(0,s.jsx)(t.p,{children:"Implementing a ZMP-based walking controller:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class ZMPWalkingController:\n    """ZMP-based walking controller"""\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = np.sqrt(gravity / com_height)\n\n        # Walking parameters\n        self.step_length = 0.3\n        self.step_width = 0.15\n        self.step_time = 0.8\n        self.zmp_reference_offset = 0.02  # Small offset for stability\n\n        # PID controller for ZMP tracking\n        self.zmp_x_pid = PIDController(kp=50.0, ki=5.0, kd=10.0)\n        self.zmp_y_pid = PIDController(kp=50.0, ki=5.0, kd=10.0)\n\n        # Foot placement variables\n        self.left_foot_pos = np.array([0.0, self.step_width, 0.0])\n        self.right_foot_pos = np.array([0.0, -self.step_width, 0.0])\n        self.next_foot_placement = "left"\n        self.step_count = 0\n\n        # Walking state\n        self.is_walking = False\n        self.walk_time = 0.0\n\n    def start_walking(self, step_length=0.3, step_width=0.15, step_time=0.8):\n        """Initialize walking with given parameters"""\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_time = step_time\n        self.is_walking = True\n        self.walk_time = 0.0\n        self.step_count = 0\n\n    def generate_zmp_trajectory(self, walk_time):\n        """Generate reference ZMP trajectory for walking"""\n        # Create a periodic ZMP pattern\n        cycle_time = walk_time % (self.step_time * 2)  # Two steps per cycle\n\n        # Basic ZMP pattern: oscillate around nominal position\n        nominal_x = (self.step_count + cycle_time / (self.step_time * 2)) * self.step_length\n\n        # Add small oscillations for stability\n        oscillation = 0.01 * np.sin(2 * np.pi * cycle_time / self.step_time)\n\n        # Y position alternates between feet\n        if self.next_foot_placement == "left":\n            nominal_y = -self.zmp_reference_offset\n        else:\n            nominal_y = self.zmp_reference_offset\n\n        return np.array([nominal_x, nominal_y])\n\n    def update_walking(self, current_com, current_com_vel, dt):\n        """Update walking controller"""\n        if not self.is_walking:\n            return np.zeros(6)  # No torques when not walking\n\n        # Update timing\n        self.walk_time += dt\n\n        # Generate reference ZMP\n        zmp_ref = self.generate_zmp_trajectory(self.walk_time)\n\n        # Compute current ZMP\n        com_acc = self.estimate_com_acceleration(current_com, current_com_vel, dt)\n        current_zmp = self.compute_zmp_from_com(current_com, com_acc)\n\n        # Compute ZMP error and required torques\n        zmp_error = zmp_ref - current_zmp[:2]\n\n        # Use PID controllers to compute corrective torques\n        torque_x = self.zmp_x_pid.update(zmp_ref[0], current_zmp[0], dt)\n        torque_y = self.zmp_y_pid.update(zmp_ref[1], current_zmp[1], dt)\n\n        # Map to joint torques (simplified mapping)\n        joint_torques = self.map_zmp_torques_to_joints(torque_x, torque_y)\n\n        # Check for step timing\n        self.check_step_timing(current_com)\n\n        return joint_torques\n\n    def estimate_com_acceleration(self, current_com, current_com_vel, dt):\n        """Estimate CoM acceleration from velocity"""\n        # This would typically come from a state estimator\n        # For now, we\'ll use a simple backward difference\n        if not hasattr(self, \'prev_vel\'):\n            self.prev_vel = current_com_vel.copy()\n            return np.zeros(3)\n\n        com_acc = (current_com_vel - self.prev_vel) / dt\n        self.prev_vel = current_com_vel.copy()\n        return com_acc\n\n    def compute_zmp_from_com(self, com_pos, com_acc):\n        """Compute ZMP from CoM state"""\n        zmp_x = com_pos[0] - (com_acc[0] * self.com_height / self.gravity)\n        zmp_y = com_pos[1] - (com_acc[1] * self.com_height / self.gravity)\n        return np.array([zmp_x, zmp_y, 0])\n\n    def map_zmp_torques_to_joints(self, torque_x, torque_y):\n        """Map ZMP torques to joint torques (simplified)"""\n        # This is a simplified mapping - in reality, this would involve\n        # whole-body control and inverse dynamics\n        torques = np.zeros(6)  # 6-DOF torques at base\n\n        # Map X torque to hip pitch\n        torques[3] = torque_x * 50  # Scale factor\n\n        # Map Y torque to hip roll\n        torques[4] = -torque_y * 50  # Scale factor\n\n        return torques\n\n    def check_step_timing(self, current_com):\n        """Check if it\'s time to take the next step"""\n        cycle_time = self.walk_time % self.step_time\n\n        # Take step when we reach the end of the step phase\n        if (cycle_time < self.step_time / 4 or  # Beginning of new step phase\n            (self.walk_time // self.step_time) > self.step_count):  # New step interval\n\n            new_step_count = int(self.walk_time // self.step_time)\n            if new_step_count > self.step_count:\n                self.step_count = new_step_count\n                # Place next foot\n                if self.next_foot_placement == "left":\n                    self.left_foot_pos = np.array([\n                        self.step_count * self.step_length,\n                        self.step_width,\n                        0.0\n                    ])\n                    self.next_foot_placement = "right"\n                else:\n                    self.right_foot_pos = np.array([\n                        self.step_count * self.step_length,\n                        -self.step_width,\n                        0.0\n                    ])\n                    self.next_foot_placement = "left"\n\n    def stop_walking(self):\n        """Stop walking motion"""\n        self.is_walking = False\n        # Implement stopping strategy (e.g., capture point approach)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"simple-stepping-pattern",children:"Simple Stepping Pattern"}),"\n",(0,s.jsx)(t.p,{children:"Creating basic stepping patterns for balance recovery:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class SteppingPatternGenerator:\n    """Generate stepping patterns for balance recovery"""\n    def __init__(self, step_length=0.3, step_width=0.15):\n        self.step_length = step_length\n        self.step_width = step_width\n\n    def compute_capture_point(self, com_pos, com_vel, com_height=0.8, gravity=9.81):\n        """Compute capture point from CoM state"""\n        omega = np.sqrt(gravity / com_height)\n        capture_point = com_pos[:2] + com_vel[:2] / omega\n        return capture_point\n\n    def generate_recovery_step(self, current_support_pos, com_state, strategy="capture_point"):\n        """Generate a recovery step based on current state"""\n        com_pos = com_state[\'position\']\n        com_vel = com_state[\'velocity\']\n        com_height = com_state.get(\'height\', 0.8)\n\n        if strategy == "capture_point":\n            # Place foot at or beyond capture point\n            capture_point = self.compute_capture_point(com_pos, com_vel, com_height)\n\n            # Ensure step is in a reasonable direction\n            step_direction = capture_point - current_support_pos[:2]\n            step_distance = np.linalg.norm(step_direction)\n\n            # Limit step size\n            max_step = self.step_length * 1.5  # 1.5x normal step\n            if step_distance > max_step:\n                step_direction = step_direction / step_distance * max_step\n\n            step_pos = current_support_pos.copy()\n            step_pos[:2] = current_support_pos[:2] + step_direction\n\n            return step_pos\n\n        elif strategy == "directional":\n            # Step in the direction opposite to CoM offset\n            com_offset = com_pos[:2] - current_support_pos[:2]\n            step_direction = -com_offset\n            step_distance = np.linalg.norm(step_direction)\n\n            # Normalize and scale\n            if step_distance > 0:\n                step_direction = step_direction / step_distance\n                step_size = min(step_distance * 1.2, self.step_length * 1.5)\n                step_direction *= step_size\n\n            step_pos = current_support_pos.copy()\n            step_pos[:2] = current_support_pos[:2] + step_direction\n\n            return step_pos\n\n    def generate_omni_directional_step(self, direction, distance=None):\n        """Generate a step in any direction"""\n        if distance is None:\n            distance = self.step_length\n\n        step_x = distance * np.cos(direction)\n        step_y = distance * np.sin(direction)\n\n        return np.array([step_x, step_y, 0.0])\n\n# Example: Recovery step generation\nrecovery_gen = SteppingPatternGenerator()\ncurrent_support = np.array([0.0, 0.1, 0.0])  # Left foot position\ncom_state = {\n    \'position\': np.array([0.1, 0.15, 0.8]),\n    \'velocity\': np.array([0.05, 0.02, 0.0]),\n    \'height\': 0.8\n}\n\nrecovery_step = recovery_gen.generate_recovery_step(current_support, com_state)\nprint(f"Recovery step position: {recovery_step}")\n'})}),"\n",(0,s.jsx)(t.h2,{id:"walk-pattern-generator",children:"Walk Pattern Generator"}),"\n",(0,s.jsx)(t.p,{children:"Creating complete walk patterns:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class WalkPatternGenerator:\n    \"\"\"Generate complete walking patterns\"\"\"\n    def __init__(self, step_length=0.3, step_width=0.15, step_time=0.8):\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_time = step_time\n        self.stepping_gen = SteppingPatternGenerator(step_length, step_width)\n\n    def generate_walk_pattern(self, num_steps, start_pos=np.array([0, 0, 0.8])):\n        \"\"\"Generate a complete walk pattern\"\"\"\n        pattern = {\n            'com_trajectory': [],\n            'left_foot_trajectory': [],\n            'right_foot_trajectory': [],\n            'zmp_trajectory': [],\n            'timestamps': []\n        }\n\n        # Initial positions\n        left_foot = start_pos + np.array([0, self.step_width, 0])\n        right_foot = start_pos + np.array([0, -self.step_width, 0])\n\n        com_pos = start_pos.copy()\n        com_vel = np.array([0, 0, 0])\n\n        dt = 0.005  # 200 Hz\n        time = 0\n\n        for step in range(num_steps):\n            # Simulate one step cycle\n            step_duration = self.step_time\n            steps_in_cycle = int(step_duration / dt)\n\n            for i in range(steps_in_cycle):\n                t = i * dt\n\n                # Simple forward progression\n                com_pos[0] = start_pos[0] + (step + t/self.step_time) * self.step_length\n                com_pos[1] = start_pos[1] + (-1)**step * 0.02 * np.sin(2*np.pi*t/self.step_time)  # Small lateral sway\n\n                # Foot trajectories\n                if step % 2 == 0:  # Left foot swings\n                    left_x = step * self.step_length + t/self.step_time * self.step_length\n                    left_y = self.step_width * (1 - t/self.step_time)  # Return to center\n                    left_foot = np.array([left_x, left_y, 0])\n                    right_foot = np.array([(step+1) * self.step_length, -self.step_width, 0])\n                else:  # Right foot swings\n                    right_x = step * self.step_length + t/self.step_time * self.step_length\n                    right_y = -self.step_width * (1 - t/self.step_time)  # Return to center\n                    right_foot = np.array([right_x, right_y, 0])\n                    left_foot = np.array([step * self.step_length, self.step_width, 0])\n\n                # Calculate ZMP (simplified)\n                zmp = np.array([com_pos[0] - 0.02, com_pos[1]])  # Small offset\n\n                # Store data\n                pattern['com_trajectory'].append(com_pos.copy())\n                pattern['left_foot_trajectory'].append(left_foot.copy())\n                pattern['right_foot_trajectory'].append(right_foot.copy())\n                pattern['zmp_trajectory'].append(zmp.copy())\n                pattern['timestamps'].append(time)\n\n                time += dt\n\n        # Convert to numpy arrays\n        for key in pattern:\n            if key != 'timestamps':\n                pattern[key] = np.array(pattern[key])\n\n        return pattern\n\n    def generate_turning_pattern(self, angle, turn_radius=0.5):\n        \"\"\"Generate a turning walking pattern\"\"\"\n        # Calculate number of steps needed for turn\n        arc_length = turn_radius * abs(angle)\n        num_steps = int(arc_length / self.step_length) + 1\n\n        pattern = {\n            'com_trajectory': [],\n            'left_foot_trajectory': [],\n            'right_foot_trajectory': [],\n            'zmp_trajectory': [],\n            'timestamps': []\n        }\n\n        current_angle = 0\n        current_pos = np.array([0, 0, 0.8])\n\n        for step in range(num_steps):\n            # Calculate turning angle for this step\n            step_angle = angle * step / num_steps\n            next_step_angle = angle * (step + 1) / num_steps\n\n            # Calculate positions along arc\n            avg_angle = (current_angle + step_angle) / 2\n            dx = (next_step_angle - current_angle) * turn_radius * np.cos(avg_angle + np.pi/2)\n            dy = (next_step_angle - current_angle) * turn_radius * np.sin(avg_angle + np.pi/2)\n\n            current_pos[0] += dx\n            current_pos[1] += dy\n\n            # Foot positions during turn\n            # Simplified turning model\n            left_pos = current_pos + np.array([0, self.step_width, 0])\n            right_pos = current_pos + np.array([0, -self.step_width, 0])\n\n            pattern['com_trajectory'].append(current_pos.copy())\n            pattern['left_foot_trajectory'].append(left_pos)\n            pattern['right_foot_trajectory'].append(right_pos)\n            pattern['zmp_trajectory'].append(current_pos[:2].copy())\n            pattern['timestamps'].append(step * self.step_time)\n\n            current_angle = step_angle\n\n        # Convert to numpy arrays\n        for key in pattern:\n            if key != 'timestamps':\n                pattern[key] = np.array(pattern[key])\n\n        return pattern\n\n# Example usage\npattern_gen = WalkPatternGenerator(step_length=0.3, step_width=0.15, step_time=0.8)\nwalk_pattern = pattern_gen.generate_walk_pattern(4)  # 4 steps forward\n\nprint(f\"Generated walk pattern with {len(walk_pattern['com_trajectory'])} time steps\")\nprint(f\"Final CoM position: {walk_pattern['com_trajectory'][-1]}\")\n"})}),"\n",(0,s.jsx)(t.h2,{id:"practical-walking-controller",children:"Practical Walking Controller"}),"\n",(0,s.jsx)(t.p,{children:"A complete walking controller that combines all elements:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class PracticalWalkingController:\n    """Practical walking controller combining all elements"""\n    def __init__(self, com_height=0.8):\n        self.zmp_controller = ZMPWalkingController(com_height=com_height)\n        self.pattern_generator = WalkPatternGenerator()\n        self.stepping_generator = SteppingPatternGenerator()\n\n        # Walking state\n        self.current_com = np.array([0, 0, com_height])\n        self.current_com_vel = np.array([0, 0, 0])\n        self.walk_speed = 0.0  # Current walking speed\n        self.walk_direction = 0.0  # Walking direction in radians\n\n    def start_walking(self, speed=0.3, direction=0.0):\n        """Start walking at specified speed and direction"""\n        self.walk_speed = speed\n        self.walk_direction = direction\n\n        # Adjust step parameters based on speed\n        step_time = max(0.6, 0.8 - speed * 0.2)  # Faster = shorter steps\n        step_length = min(0.4, speed * step_time * 0.8)  # Adjust step length\n\n        self.zmp_controller.start_walking(\n            step_length=step_length,\n            step_width=0.15,\n            step_time=step_time\n        )\n\n    def update_walking(self, sensor_data, dt):\n        """Main walking control update"""\n        # Extract sensor data\n        self.current_com = sensor_data.get(\'com_position\', self.current_com)\n        self.current_com_vel = sensor_data.get(\'com_velocity\', self.current_com_vel)\n\n        # Update ZMP-based walking controller\n        torques = self.zmp_controller.update_walking(self.current_com, self.current_com_vel, dt)\n\n        # Check for balance recovery needs\n        com_offset = np.linalg.norm(self.current_com[:2])\n        if com_offset > 0.15:  # Too far from center\n            # Generate recovery step\n            support_foot = self.get_current_support_foot()\n            recovery_step = self.stepping_generator.generate_recovery_step(\n                support_foot,\n                {\'position\': self.current_com, \'velocity\': self.current_com_vel}\n            )\n            print(f"Balance recovery step needed at: {recovery_step}")\n\n        return torques\n\n    def get_current_support_foot(self):\n        """Get position of current support foot"""\n        # This would typically come from contact sensors\n        # For now, we\'ll use the controller\'s internal state\n        if self.zmp_controller.next_foot_placement == "left":\n            return self.zmp_controller.right_foot_pos\n        else:\n            return self.zmp_controller.left_foot_pos\n\n    def turn_in_place(self, angle):\n        """Execute turning in place"""\n        # Generate turning pattern\n        turn_pattern = self.pattern_generator.generate_turning_pattern(angle)\n        return turn_pattern\n\n    def stop_walking(self):\n        """Stop walking with safe deceleration"""\n        self.zmp_controller.stop_walking()\n        self.walk_speed = 0.0\n\n# Example usage\ndef example_walking():\n    controller = PracticalWalkingController(com_height=0.85)\n\n    # Start walking forward\n    controller.start_walking(speed=0.4, direction=0.0)  # 0.4 m/s forward\n\n    # Simulated sensor data\n    sensor_data = {\n        \'com_position\': np.array([0.1, 0.0, 0.85]),\n        \'com_velocity\': np.array([0.3, 0.0, 0.0])\n    }\n\n    dt = 0.005  # 200 Hz\n\n    for i in range(10):  # 10 control cycles\n        torques = controller.update_walking(sensor_data, dt)\n        print(f"Control cycle {i+1}: Torques = {torques[:3]}...")  # Show first 3 torques\n\n        # Update sensor data for next cycle (simulated)\n        sensor_data[\'com_position\'][0] += sensor_data[\'com_velocity\'][0] * dt\n        sensor_data[\'com_position\'][1] += 0.001 * np.sin(i)  # Small lateral movement\n\nif __name__ == "__main__":\n    example_walking()\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Start with simple patterns"}),": Begin with basic stepping before complex gaits"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Prioritize stability"}),": Always ensure ZMP remains in support polygon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Test incrementally"}),": Validate each component separately"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Consider terrain"}),": Adapt step patterns for different surfaces"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Implement safety margins"}),": Keep adequate stability margins"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Smooth transitions"}),": Ensure smooth transitions between steps"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Implement a walking controller that can adjust step length based on walking speed."}),"\n",(0,s.jsx)(t.li,{children:"Create a turning controller that maintains balance during turns."}),"\n",(0,s.jsx)(t.li,{children:"Design a disturbance recovery system that automatically takes recovery steps."}),"\n"]})]})}function _(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const r={},o=s.createContext(r);function a(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);