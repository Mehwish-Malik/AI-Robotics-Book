"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[654],{5172:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=i(4848),s=i(8453);const o={sidebar_position:3},r="Chapter 3: Basic Concepts and Terminology",a={id:"modules/module-1-fundamentals/chapter-3-basic-concepts",title:"Chapter 3: Basic Concepts and Terminology",description:"Summary",source:"@site/docs/modules/module-1-fundamentals/chapter-3-basic-concepts.md",sourceDirName:"modules/module-1-fundamentals",slug:"/modules/module-1-fundamentals/chapter-3-basic-concepts",permalink:"/docs/modules/module-1-fundamentals/chapter-3-basic-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/Mehwish-Malik/AI-Robotics-Book.git/docs/modules/module-1-fundamentals/chapter-3-basic-concepts.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Chapter 2: Historical Development and Evolution",permalink:"/docs/modules/module-1-fundamentals/chapter-2-history"},next:{title:"Chapter 4: Actuators and Motor Systems",permalink:"/docs/modules/module-2-hardware/chapter-4-actuators"}},l={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Coordinate Systems in Humanoid Robotics",id:"coordinate-systems-in-humanoid-robotics",level:2},{value:"World Coordinate System",id:"world-coordinate-system",level:3},{value:"Body Coordinate System",id:"body-coordinate-system",level:3},{value:"Joint Coordinate Systems",id:"joint-coordinate-systems",level:3},{value:"End-Effector Coordinate Systems",id:"end-effector-coordinate-systems",level:3},{value:"Degrees of Freedom and Mobility",id:"degrees-of-freedom-and-mobility",level:2},{value:"Definition of Degrees of Freedom",id:"definition-of-degrees-of-freedom",level:3},{value:"Calculating DOF for Humanoid Systems",id:"calculating-dof-for-humanoid-systems",level:3},{value:"DOF in Humanoid Robots",id:"dof-in-humanoid-robots",level:3},{value:"Redundant DOF",id:"redundant-dof",level:3},{value:"Static vs. Dynamic Stability",id:"static-vs-dynamic-stability",level:2},{value:"Static Stability",id:"static-stability",level:3},{value:"Dynamic Stability",id:"dynamic-stability",level:3},{value:"Stability Metrics",id:"stability-metrics",level:3},{value:"Center of Mass and Balance",id:"center-of-mass-and-balance",level:2},{value:"Center of Mass Calculation",id:"center-of-mass-calculation",level:3},{value:"Balance Control Strategies",id:"balance-control-strategies",level:3},{value:"Kinematic Representations",id:"kinematic-representations",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Jacobian Matrix",id:"jacobian-matrix",level:3},{value:"Mathematical Representations",id:"mathematical-representations",level:2},{value:"Homogeneous Transformation Matrices",id:"homogeneous-transformation-matrices",level:3},{value:"Rotation Representations",id:"rotation-representations",level:3},{value:"Denavit-Hartenberg Parameters",id:"denavit-hartenberg-parameters",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Robot Calibration",id:"robot-calibration",level:3},{value:"Control System Design",id:"control-system-design",level:3},{value:"Stability Analysis",id:"stability-analysis",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Modeling Accuracy",id:"modeling-accuracy",level:3},{value:"Environmental Adaptation",id:"environmental-adaptation",level:3},{value:"Figure List",id:"figure-list",level:2},{value:"Code Example: Kinematic Calculations",id:"code-example-kinematic-calculations",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary-1",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"chapter-3-basic-concepts-and-terminology",children:"Chapter 3: Basic Concepts and Terminology"}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter establishes the fundamental concepts and terminology essential for understanding humanoid robotics. We'll explore coordinate systems, degrees of freedom, stability concepts, and mathematical representations that form the foundation for more advanced topics. Understanding these concepts is crucial for grasping the complexities of humanoid robot design and control."}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Explain different coordinate systems used in humanoid robotics"}),"\n",(0,t.jsx)(e.li,{children:"Calculate and analyze degrees of freedom in robotic systems"}),"\n",(0,t.jsx)(e.li,{children:"Understand static and dynamic stability concepts"}),"\n",(0,t.jsx)(e.li,{children:"Apply mathematical representations for robot kinematics"}),"\n",(0,t.jsx)(e.li,{children:"Identify key terminology used throughout the field"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Coordinate Systems"}),": Reference frames for describing robot position and orientation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Degrees of Freedom (DOF)"}),": Independent movements a mechanical system can perform"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Kinematic Chains"}),": Series of rigid bodies connected by joints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Stability"}),": Stability without motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Stability"}),": Stability maintained through active control during motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Center of Mass"}),": Point where the total mass of the system can be considered concentrated"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"coordinate-systems-in-humanoid-robotics",children:"Coordinate Systems in Humanoid Robotics"}),"\n",(0,t.jsx)(e.h3,{id:"world-coordinate-system",children:"World Coordinate System"}),"\n",(0,t.jsx)(e.p,{children:"The world coordinate system is a fixed reference frame that defines the global environment in which the robot operates. It typically uses a right-handed coordinate system:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"X-axis"}),": Points forward (in the direction of intended movement)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Y-axis"}),": Points to the left"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Z-axis"}),": Points upward (opposing gravity)"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This system is essential for navigation, mapping, and understanding the robot's position relative to its environment."}),"\n",(0,t.jsx)(e.h3,{id:"body-coordinate-system",children:"Body Coordinate System"}),"\n",(0,t.jsx)(e.p,{children:"The body coordinate system is attached to the robot's torso or base link. It moves with the robot and provides a reference for the robot's own perspective:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Origin"}),": Usually located at the robot's center of mass or at the pelvis"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Orientation"}),": Typically aligned with the robot's forward direction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Purpose"}),": Simplifies control of limbs relative to the body"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"joint-coordinate-systems",children:"Joint Coordinate Systems"}),"\n",(0,t.jsx)(e.p,{children:"Each joint has its own coordinate system that defines the range of motion for that specific joint:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rotation Axes"}),": Define the directions in which the joint can rotate"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Translation Axes"}),": Define the directions in which the joint can translate (for prismatic joints)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint Limits"}),": Define the mechanical constraints on movement"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"end-effector-coordinate-systems",children:"End-Effector Coordinate Systems"}),"\n",(0,t.jsx)(e.p,{children:"End-effectors (hands, feet) have coordinate systems that define their orientation and position:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hand Frame"}),": Defines the orientation of the hand for grasping"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Foot Frame"}),": Defines the orientation of the foot for walking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tool Frame"}),": Defines the orientation of any attached tools"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"degrees-of-freedom-and-mobility",children:"Degrees of Freedom and Mobility"}),"\n",(0,t.jsx)(e.h3,{id:"definition-of-degrees-of-freedom",children:"Definition of Degrees of Freedom"}),"\n",(0,t.jsx)(e.p,{children:"Degrees of freedom (DOF) represent the number of independent parameters that define the configuration of a mechanical system. For a rigid body in 3D space, there are 6 DOF: 3 for translation and 3 for rotation."}),"\n",(0,t.jsx)(e.h3,{id:"calculating-dof-for-humanoid-systems",children:"Calculating DOF for Humanoid Systems"}),"\n",(0,t.jsx)(e.p,{children:"The mobility of a robotic system can be calculated using Gruebler's equation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"DOF = \u03bb(N - 1) - \u03a3(\u03bb - f_i)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u03bb = degrees of freedom of the space (6 for spatial mechanisms)"}),"\n",(0,t.jsx)(e.li,{children:"N = number of links including ground"}),"\n",(0,t.jsx)(e.li,{children:"f_i = degrees of freedom of joint i"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"For a simple serial chain:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"DOF = \u03a3(f_i) - constraints\n"})}),"\n",(0,t.jsx)(e.h3,{id:"dof-in-humanoid-robots",children:"DOF in Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"A typical humanoid robot has multiple kinematic chains:"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Right Arm Chain"})," (7 DOF):"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Shoulder: 3 DOF (pitch, yaw, roll)"}),"\n",(0,t.jsx)(e.li,{children:"Elbow: 1 DOF (flexion/extension)"}),"\n",(0,t.jsx)(e.li,{children:"Wrist: 3 DOF (pitch, yaw, roll)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Right Leg Chain"})," (6 DOF):"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Hip: 3 DOF (flexion/extension, abduction/adduction, internal/external rotation)"}),"\n",(0,t.jsx)(e.li,{children:"Knee: 1 DOF (flexion/extension)"}),"\n",(0,t.jsx)(e.li,{children:"Ankle: 2 DOF (dorsiflexion/plantarflexion, inversion/eversion)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"redundant-dof",children:"Redundant DOF"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots often have redundant DOF, meaning they have more DOF than necessary to achieve a task. This redundancy provides:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexibility"}),": Multiple ways to achieve the same goal"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Avoidance"}),": Ability to navigate around obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimization"}),": Capability to optimize secondary objectives (energy, comfort)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"static-vs-dynamic-stability",children:"Static vs. Dynamic Stability"}),"\n",(0,t.jsx)(e.h3,{id:"static-stability",children:"Static Stability"}),"\n",(0,t.jsx)(e.p,{children:"Static stability refers to the robot's ability to maintain balance without motion. For static balance, the center of mass (CoM) must be positioned within the support polygon (the convex hull of all contact points with the ground)."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Key Principles"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Center of mass must be within the support base"}),"\n",(0,t.jsx)(e.li,{children:"Larger support base provides greater stability"}),"\n",(0,t.jsx)(e.li,{children:"Lower center of mass improves stability"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"dynamic-stability",children:"Dynamic Stability"}),"\n",(0,t.jsx)(e.p,{children:"Dynamic stability involves maintaining balance during motion. Unlike static stability, the robot can be dynamically stable even when the center of mass is outside the support polygon, provided that appropriate control actions are taken."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Key Principles"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Zero Moment Point (ZMP) must be within the support polygon"}),"\n",(0,t.jsx)(e.li,{children:"Continuous adjustment of control parameters"}),"\n",(0,t.jsx)(e.li,{children:"Use of momentum to maintain balance"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"stability-metrics",children:"Stability Metrics"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Center of Pressure (CoP)"}),": The point where the ground reaction force acts."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": The point where the moment of the ground reaction force and gravity force equals zero."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Capture Point"}),": The point where the robot must step to come to a complete stop."]}),"\n",(0,t.jsx)(e.h2,{id:"center-of-mass-and-balance",children:"Center of Mass and Balance"}),"\n",(0,t.jsx)(e.h3,{id:"center-of-mass-calculation",children:"Center of Mass Calculation"}),"\n",(0,t.jsx)(e.p,{children:"The center of mass of a system of particles is given by:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"CoM = \u03a3(m_i * r_i) / \u03a3(m_i)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"m_i = mass of particle i"}),"\n",(0,t.jsx)(e.li,{children:"r_i = position vector of particle i"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"For continuous bodies:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"CoM = \u222b r dm / \u222b dm\n"})}),"\n",(0,t.jsx)(e.h3,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Ankle Strategy"}),": Small balance adjustments using ankle torques (effective for small disturbances)"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Hip Strategy"}),": Larger adjustments using hip torques (effective for medium disturbances)"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Stepping Strategy"}),": Taking a step to expand the support base (effective for large disturbances)"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Suspension Strategy"}),": Moving the center of mass to maintain balance (for dynamic situations)"]}),"\n",(0,t.jsx)(e.h2,{id:"kinematic-representations",children:"Kinematic Representations"}),"\n",(0,t.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of the end-effector given the joint angles:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T = f(\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where T is the transformation matrix and \u03b8\u1d62 are the joint angles."}),"\n",(0,t.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Inverse kinematics calculates the required joint angles to achieve a desired end-effector position and orientation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099 = f\u207b\xb9(T)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"jacobian-matrix",children:"Jacobian Matrix"}),"\n",(0,t.jsx)(e.p,{children:"The Jacobian matrix relates joint velocities to end-effector velocities:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v = J(\u03b8) * \u03b8\u0307\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"v = end-effector velocity vector"}),"\n",(0,t.jsx)(e.li,{children:"J = Jacobian matrix"}),"\n",(0,t.jsx)(e.li,{children:"\u03b8\u0307 = joint velocity vector"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"mathematical-representations",children:"Mathematical Representations"}),"\n",(0,t.jsx)(e.h3,{id:"homogeneous-transformation-matrices",children:"Homogeneous Transformation Matrices"}),"\n",(0,t.jsx)(e.p,{children:"Homogeneous transformation matrices represent both rotation and translation in a single 4\xd74 matrix:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T = [R  p]\n    [0  1]\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where R is a 3\xd73 rotation matrix and p is a 3\xd71 position vector."}),"\n",(0,t.jsx)(e.h3,{id:"rotation-representations",children:"Rotation Representations"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Rotation Matrices"}),": 3\xd73 orthogonal matrices\n",(0,t.jsx)(e.strong,{children:"Euler Angles"}),": Three angles representing sequential rotations\n",(0,t.jsx)(e.strong,{children:"Quaternions"}),": Four-parameter representation avoiding gimbal lock\n",(0,t.jsx)(e.strong,{children:"Axis-Angle"}),": Rotation around a specific axis"]}),"\n",(0,t.jsx)(e.h3,{id:"denavit-hartenberg-parameters",children:"Denavit-Hartenberg Parameters"}),"\n",(0,t.jsx)(e.p,{children:"The Denavit-Hartenberg (DH) convention provides a systematic way to define coordinate frames on robotic linkages:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"a\u1d62"}),": Link length"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"\u03b1\u1d62"}),": Link twist"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"d\u1d62"}),": Link offset"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"\u03b8\u1d62"}),": Joint angle"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,t.jsx)(e.h3,{id:"robot-calibration",children:"Robot Calibration"}),"\n",(0,t.jsx)(e.p,{children:"Understanding coordinate systems is essential for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Tool calibration"}),"\n",(0,t.jsx)(e.li,{children:"Sensor integration"}),"\n",(0,t.jsx)(e.li,{children:"Workspace definition"}),"\n",(0,t.jsx)(e.li,{children:"Collision avoidance"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"control-system-design",children:"Control System Design"}),"\n",(0,t.jsx)(e.p,{children:"DOF analysis is crucial for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Controller design"}),"\n",(0,t.jsx)(e.li,{children:"Trajectory planning"}),"\n",(0,t.jsx)(e.li,{children:"Singularity avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Redundancy resolution"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"stability-analysis",children:"Stability Analysis"}),"\n",(0,t.jsx)(e.p,{children:"Stability concepts are applied to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Gait planning"}),"\n",(0,t.jsx)(e.li,{children:"Balance control"}),"\n",(0,t.jsx)(e.li,{children:"Disturbance rejection"}),"\n",(0,t.jsx)(e.li,{children:"Safe operation"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"challenges",children:"Challenges"}),"\n",(0,t.jsx)(e.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"High DOF systems require significant computational resources"}),"\n",(0,t.jsx)(e.li,{children:"Real-time control of complex kinematic chains"}),"\n",(0,t.jsx)(e.li,{children:"Optimization of redundant DOF"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"modeling-accuracy",children:"Modeling Accuracy"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Precise modeling of complex mechanical systems"}),"\n",(0,t.jsx)(e.li,{children:"Accounting for flexibility and non-linearities"}),"\n",(0,t.jsx)(e.li,{children:"Parameter identification for control"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"environmental-adaptation",children:"Environmental Adaptation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Operating in unstructured environments"}),"\n",(0,t.jsx)(e.li,{children:"Handling uncertainty in sensor data"}),"\n",(0,t.jsx)(e.li,{children:"Adapting to changing conditions"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"figure-list",children:"Figure List"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Figure 3.1"}),": Coordinate system definitions for humanoid robots"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Figure 3.2"}),": Degrees of freedom in human vs. robotic joints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Figure 3.3"}),": Static vs. dynamic stability concepts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Figure 3.4"}),": Center of mass and support polygon visualization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Figure 3.5"}),": Kinematic chain representations"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"code-example-kinematic-calculations",children:"Code Example: Kinematic Calculations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\ndef dh_transform(a: float, alpha: float, d: float, theta: float) -> np.ndarray:\n    """\n    Calculate Denavit-Hartenberg transformation matrix\n\n    Args:\n        a: Link length\n        alpha: Link twist\n        d: Link offset\n        theta: Joint angle\n\n    Returns:\n        4x4 homogeneous transformation matrix\n    """\n    cos_th = np.cos(theta)\n    sin_th = np.sin(theta)\n    cos_alpha = np.cos(alpha)\n    sin_alpha = np.sin(alpha)\n\n    return np.array([\n        [cos_th, -sin_th * cos_alpha, sin_th * sin_alpha, a * cos_th],\n        [sin_th, cos_th * cos_alpha, -cos_th * sin_alpha, a * sin_th],\n        [0, sin_alpha, cos_alpha, d],\n        [0, 0, 0, 1]\n    ])\n\ndef forward_kinematics(dh_params: List[Tuple[float, float, float, float]]) -> np.ndarray:\n    """\n    Calculate forward kinematics using DH parameters\n\n    Args:\n        dh_params: List of (a, alpha, d, theta) tuples for each joint\n\n    Returns:\n        Final transformation matrix\n    """\n    T = np.eye(4)  # Start with identity matrix\n    for a, alpha, d, theta in dh_params:\n        T_joint = dh_transform(a, alpha, d, theta)\n        T = T @ T_joint  # Matrix multiplication\n    return T\n\ndef calculate_center_of_mass(masses: List[float], positions: List[np.ndarray]) -> np.ndarray:\n    """\n    Calculate center of mass for a multi-body system\n\n    Args:\n        masses: List of masses for each body\n        positions: List of position vectors for each body\n\n    Returns:\n        Center of mass position vector\n    """\n    if len(masses) != len(positions):\n        raise ValueError("Masses and positions must have the same length")\n\n    total_mass = sum(masses)\n    if total_mass == 0:\n        return np.zeros(3)\n\n    weighted_sum = np.zeros(3)\n    for mass, pos in zip(masses, positions):\n        weighted_sum += mass * pos\n\n    return weighted_sum / total_mass\n\ndef is_statically_stable(com: np.ndarray, support_polygon: List[np.ndarray]) -> bool:\n    """\n    Check if a center of mass is within a 2D support polygon\n\n    Args:\n        com: Center of mass (x, y) coordinates\n        support_polygon: List of (x, y) coordinates defining the support polygon\n\n    Returns:\n        True if CoM is within the support polygon\n    """\n    # Convert to 2D (ignore z-coordinate for stability check)\n    x, y = com[0], com[1]\n\n    # Ray casting algorithm to check if point is inside polygon\n    n = len(support_polygon)\n    inside = False\n\n    p1x, p1y = support_polygon[0][0], support_polygon[0][1]\n    for i in range(1, n + 1):\n        p2x, p2y = support_polygon[i % n][0], support_polygon[i % n][1]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n\n    return inside\n\ndef calculate_zmp(com: np.ndarray, cop: np.ndarray, gravity: float = 9.81) -> np.ndarray:\n    """\n    Calculate Zero Moment Point given Center of Mass and Center of Pressure\n\n    Args:\n        com: Center of mass position (x, y, z)\n        cop: Center of pressure position (x, y, z)\n        gravity: Gravitational acceleration\n\n    Returns:\n        ZMP position (x, y, z)\n    """\n    # Simplified ZMP calculation for static case\n    # In practice, ZMP involves dynamic calculations\n    zmp_x = cop[0] - (com[2] - cop[2]) * (com[0] - cop[0]) / (com[2] - cop[2])\n    zmp_y = cop[1] - (com[2] - cop[2]) * (com[1] - cop[1]) / (com[2] - cop[2])\n\n    # For static case, ZMP is approximately equal to CoP\n    return np.array([cop[0], cop[1], cop[2]])\n\n# Example usage\nif __name__ == "__main__":\n    # Example: Simple 2-link arm\n    dh_params = [\n        (0.1, np.pi/2, 0.2, np.pi/4),   # Joint 1\n        (0.3, 0, 0, np.pi/6)            # Joint 2\n    ]\n\n    final_transform = forward_kinematics(dh_params)\n    print("Final transformation matrix:")\n    print(final_transform)\n\n    # Example: Center of mass calculation\n    masses = [1.0, 0.5, 0.3]  # Mass of torso, upper arm, lower arm\n    positions = [\n        np.array([0.0, 0.0, 0.8]),    # Torso CoM\n        np.array([0.1, 0.1, 0.7]),    # Upper arm CoM\n        np.array([0.2, 0.15, 0.6])    # Lower arm CoM\n    ]\n\n    com = calculate_center_of_mass(masses, positions)\n    print(f"\\nCenter of mass: {com}")\n\n    # Example: Stability check\n    support_polygon = [\n        np.array([-0.1, -0.1]),  # Foot corner 1\n        np.array([0.1, -0.1]),   # Foot corner 2\n        np.array([0.1, 0.1]),    # Foot corner 3\n        np.array([-0.1, 0.1])    # Foot corner 4\n    ]\n\n    robot_com = np.array([0.05, 0.0, 0.0])  # Robot\'s CoM projected to ground\n    stable = is_statically_stable(robot_com, support_polygon)\n    print(f"Is robot statically stable? {stable}")\n\n    # Example: ZMP calculation\n    cop = np.array([0.0, 0.0, 0.0])  # Center of pressure\n    zmp = calculate_zmp(com, cop)\n    print(f"ZMP position: {zmp}")\n'})}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Calculate the degrees of freedom for a humanoid robot with 6 DOF arms, 6 DOF legs, and 3 DOF head."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Determine if a robot with CoM at (0.05, 0.0, 0.0) is statically stable with a square foot of 0.2m \xd7 0.2m centered at origin."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Implement forward kinematics for a 3-DOF planar manipulator and verify the results."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-1",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter established the fundamental concepts and terminology essential for understanding humanoid robotics. We explored coordinate systems, degrees of freedom, stability concepts, and mathematical representations that form the foundation for more advanced topics. These concepts are crucial for grasping the complexities of humanoid robot design, analysis, and control."})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);