"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[705],{3:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"modules/module-3-control/chapter-8-locomotion","title":"Chapter 8: Locomotion and Gait Control","description":"Summary","source":"@site/docs/modules/module-3-control/chapter-8-locomotion.md","sourceDirName":"modules/module-3-control","slug":"/modules/module-3-control/chapter-8-locomotion","permalink":"/docs/modules/module-3-control/chapter-8-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/modules/module-3-control/chapter-8-locomotion.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7: Motion Planning and Locomotion","permalink":"/docs/modules/module-3-control/chapter-7-motion-planning"},"next":{"title":"Chapter 9: Balance and Stability Control","permalink":"/docs/modules/module-3-control/chapter-9-balance"}}');var i=r(4848),o=r(8453);const a={sidebar_position:2},l="Chapter 8: Locomotion and Gait Control",s={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Introduction to Bipedal Locomotion",id:"introduction-to-bipedal-locomotion",level:2},{value:"Locomotion Fundamentals",id:"locomotion-fundamentals",level:3},{value:"Walking Pattern Characteristics",id:"walking-pattern-characteristics",level:3},{value:"Gait Generation and Pattern Formation",id:"gait-generation-and-pattern-formation",level:2},{value:"Inverted Pendulum Model",id:"inverted-pendulum-model",level:3},{value:"Linear Inverted Pendulum Mode (LIPM)",id:"linear-inverted-pendulum-mode-lipm",level:3},{value:"Predefined Gait Patterns",id:"predefined-gait-patterns",level:3},{value:"Central Pattern Generators (CPGs)",id:"central-pattern-generators-cpgs",level:3},{value:"Zero Moment Point (ZMP) Control",id:"zero-moment-point-zmp-control",level:2},{value:"ZMP Definition",id:"zmp-definition",level:3},{value:"ZMP Stability Criteria",id:"zmp-stability-criteria",level:3},{value:"ZMP Reference Trajectory Generation",id:"zmp-reference-trajectory-generation",level:3},{value:"ZMP-Based Walking Pattern Generation",id:"zmp-based-walking-pattern-generation",level:3},{value:"Capture Point Dynamics",id:"capture-point-dynamics",level:2},{value:"Capture Point Definition",id:"capture-point-definition",level:3},{value:"Capture Point Control Strategy",id:"capture-point-control-strategy",level:3},{value:"Capture Point vs. ZMP",id:"capture-point-vs-zmp",level:3},{value:"Gait Control Algorithms",id:"gait-control-algorithms",level:2},{value:"Model Predictive Control (MPC) for Walking",id:"model-predictive-control-mpc-for-walking",level:3},{value:"Feedback Linearization",id:"feedback-linearization",level:3},{value:"Hybrid Zero Dynamics (HZD)",id:"hybrid-zero-dynamics-hzd",level:3},{value:"Dynamic Balance Control",id:"dynamic-balance-control",level:2},{value:"Balance Control Strategies",id:"balance-control-strategies",level:3},{value:"Multi-Level Balance Control",id:"multi-level-balance-control",level:3},{value:"Disturbance Rejection",id:"disturbance-rejection",level:3},{value:"Technical Depth: Mathematical Models",id:"technical-depth-mathematical-models",level:2},{value:"Walking Dynamics",id:"walking-dynamics",level:3},{value:"Linear Inverted Pendulum Model",id:"linear-inverted-pendulum-model",level:3},{value:"Discrete State Model",id:"discrete-state-model",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Walking on Different Terrains",id:"walking-on-different-terrains",level:3},{value:"Speed Control",id:"speed-control",level:3},{value:"Turning and Maneuvering",id:"turning-and-maneuvering",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Stability vs. Efficiency",id:"stability-vs-efficiency",level:3},{value:"Terrain Adaptation",id:"terrain-adaptation",level:3},{value:"Disturbance Robustness",id:"disturbance-robustness",level:3},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Figure List",id:"figure-list",level:2},{value:"Code Example: Gait Control Implementation",id:"code-example-gait-control-implementation",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary-1",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-8-locomotion-and-gait-control",children:"Chapter 8: Locomotion and Gait Control"})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter delves into the complex mechanics of bipedal locomotion, exploring the principles of walking patterns, gait generation, and the control systems that enable humanoid robots to move efficiently on two legs. We'll examine various walking patterns, gait control algorithms, and the integration of balance control with locomotion. Understanding locomotion is fundamental to creating humanoid robots that can navigate real-world environments."}),"\n",(0,i.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand the principles of bipedal locomotion and walking patterns"}),"\n",(0,i.jsx)(e.li,{children:"Analyze different gait generation algorithms and their applications"}),"\n",(0,i.jsx)(e.li,{children:"Implement Zero Moment Point (ZMP) and Capture Point control strategies"}),"\n",(0,i.jsx)(e.li,{children:"Design controllers for dynamic balance during locomotion"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate locomotion performance and stability metrics"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bipedal Locomotion"}),": Two-legged walking motion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gait Cycle"}),": Complete walking cycle including stance and swing phases"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Point where the moment of ground reaction force equals zero"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Capture Point"}),": Point where the robot must step to come to a complete stop"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Limit Cycles"}),": Stable periodic solutions representing steady-state walking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Phase-Based Control"}),": Control strategies that depend on gait phase"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Balance"}),": Balance maintained through active control during motion"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-bipedal-locomotion",children:"Introduction to Bipedal Locomotion"}),"\n",(0,i.jsx)(e.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control systems to maintain balance while moving. Unlike wheeled robots, bipedal robots have intermittent ground contact and must actively maintain stability throughout the walking cycle."}),"\n",(0,i.jsx)(e.h3,{id:"locomotion-fundamentals",children:"Locomotion Fundamentals"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Stance Phase"}),": When the foot is in contact with the ground\r\n",(0,i.jsx)(e.strong,{children:"Swing Phase"}),": When the foot is off the ground moving forward\r\n",(0,i.jsx)(e.strong,{children:"Double Support Phase"}),": When both feet are in contact with the ground\r\n",(0,i.jsx)(e.strong,{children:"Single Support Phase"}),": When only one foot is in contact with the ground"]}),"\n",(0,i.jsx)(e.h3,{id:"walking-pattern-characteristics",children:"Walking Pattern Characteristics"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Step Length"}),": Distance between consecutive foot placements\r\n",(0,i.jsx)(e.strong,{children:"Step Width"}),": Lateral distance between feet\r\n",(0,i.jsx)(e.strong,{children:"Step Time"}),": Duration of a complete gait cycle\r\n",(0,i.jsx)(e.strong,{children:"Walking Speed"}),": Forward velocity of the robot\r\n",(0,i.jsx)(e.strong,{children:"Cadence"}),": Steps per unit time"]}),"\n",(0,i.jsx)(e.h2,{id:"gait-generation-and-pattern-formation",children:"Gait Generation and Pattern Formation"}),"\n",(0,i.jsx)(e.h3,{id:"inverted-pendulum-model",children:"Inverted Pendulum Model"}),"\n",(0,i.jsx)(e.p,{children:"The simplest model for bipedal walking is the inverted pendulum:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u1e8d = g/h * x\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"x = horizontal position of center of mass"}),"\n",(0,i.jsx)(e.li,{children:"h = height of center of mass"}),"\n",(0,i.jsx)(e.li,{children:"g = gravitational acceleration"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This model shows that the center of mass behaves like an unstable pendulum that must be actively controlled."}),"\n",(0,i.jsx)(e.h3,{id:"linear-inverted-pendulum-mode-lipm",children:"Linear Inverted Pendulum Mode (LIPM)"}),"\n",(0,i.jsx)(e.p,{children:"A more tractable model linearizes the inverted pendulum:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u1e8d = \u03c9\xb2 * (x - z)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u03c9\xb2 = g/h"}),"\n",(0,i.jsx)(e.li,{children:"z = ZMP position"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This model allows for analytical solutions and is widely used in gait planning."}),"\n",(0,i.jsx)(e.h3,{id:"predefined-gait-patterns",children:"Predefined Gait Patterns"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Open-Loop Patterns"}),": Fixed sequences of joint angles"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Advantages: Simple, predictable, energy-efficient"}),"\n",(0,i.jsx)(e.li,{children:"Disadvantages: Poor adaptability to disturbances"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Closed-Loop Patterns"}),": Adaptive patterns that respond to feedback"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Advantages: Better disturbance rejection, adaptability"}),"\n",(0,i.jsx)(e.li,{children:"Disadvantages: More complex, potential stability issues"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"central-pattern-generators-cpgs",children:"Central Pattern Generators (CPGs)"}),"\n",(0,i.jsx)(e.p,{children:"CPGs are neural networks that generate rhythmic patterns:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"d\u03b8/dt = \u03c9 + \u2211 w_ij * sin(\u03b8_j - \u03b8_i + \u03c6_ij)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u03b8_i = phase of oscillator i"}),"\n",(0,i.jsx)(e.li,{children:"\u03c9 = natural frequency"}),"\n",(0,i.jsx)(e.li,{children:"w_ij = coupling strength"}),"\n",(0,i.jsx)(e.li,{children:"\u03c6_ij = phase bias"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"zero-moment-point-zmp-control",children:"Zero Moment Point (ZMP) Control"}),"\n",(0,i.jsx)(e.h3,{id:"zmp-definition",children:"ZMP Definition"}),"\n",(0,i.jsx)(e.p,{children:"The Zero Moment Point is the point on the ground where the moment of the ground reaction force and gravity force equals zero:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"ZMP_x = (M_x + F_z * h) / F_z\r\nZMP_y = (M_y + F_z * h) / F_z\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"M_x, M_y = moments about x and y axes"}),"\n",(0,i.jsx)(e.li,{children:"F_z = vertical ground reaction force"}),"\n",(0,i.jsx)(e.li,{children:"h = height of center of mass"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"zmp-stability-criteria",children:"ZMP Stability Criteria"}),"\n",(0,i.jsx)(e.p,{children:"For stable walking, the ZMP must remain within the support polygon (convex hull of ground contact points)."}),"\n",(0,i.jsx)(e.h3,{id:"zmp-reference-trajectory-generation",children:"ZMP Reference Trajectory Generation"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Preview Control"}),": Uses future reference trajectory to compute current control"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"u(k) = -Kx(k) - K_f * \u03a3(i=0 to N-1) G_f(i) * r(k+i)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"u = control input"}),"\n",(0,i.jsx)(e.li,{children:"x = state"}),"\n",(0,i.jsx)(e.li,{children:"r = reference trajectory"}),"\n",(0,i.jsx)(e.li,{children:"N = preview horizon"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"zmp-based-walking-pattern-generation",children:"ZMP-Based Walking Pattern Generation"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Desired ZMP Trajectory"}),": Define stable ZMP pattern"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"COM Trajectory"}),": Integrate inverted pendulum equation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Foot Placement"}),": Determine foot positions based on COM trajectory"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Joint Trajectory"}),": Compute joint angles to achieve desired poses"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"capture-point-dynamics",children:"Capture Point Dynamics"}),"\n",(0,i.jsx)(e.h3,{id:"capture-point-definition",children:"Capture Point Definition"}),"\n",(0,i.jsx)(e.p,{children:"The capture point indicates where the robot must step to come to a complete stop:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Capture Point = CoM Position + CoM Velocity / \u03c9\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where \u03c9 = \u221a(g/h), the natural frequency of the inverted pendulum."}),"\n",(0,i.jsx)(e.h3,{id:"capture-point-control-strategy",children:"Capture Point Control Strategy"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compute Capture Point"}),": From current CoM state"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compare with Foot Location"}),": If capture point is outside support, step required"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Plan Step Location"}),": Place foot at or beyond capture point"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adjust Control"}),": Modify walking pattern accordingly"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"capture-point-vs-zmp",children:"Capture Point vs. ZMP"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"ZMP"}),": Used for trajectory planning and stability analysis\r\n",(0,i.jsx)(e.strong,{children:"Capture Point"}),": Used for step timing and placement decisions\r\n",(0,i.jsx)(e.strong,{children:"Relationship"}),": Capture point extends ZMP concept to include stopping capability"]}),"\n",(0,i.jsx)(e.h2,{id:"gait-control-algorithms",children:"Gait Control Algorithms"}),"\n",(0,i.jsx)(e.h3,{id:"model-predictive-control-mpc-for-walking",children:"Model Predictive Control (MPC) for Walking"}),"\n",(0,i.jsx)(e.p,{children:"MPC optimizes walking over a prediction horizon:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"min \u03a3(k=0 to N-1) ||x(k) - x_ref(k)||\xb2_Q + ||u(k)||\xb2_R\r\ns.t. x(k+1) = Ax(k) + Bu(k)\r\n     ZMP constraints\r\n     State constraints\n"})}),"\n",(0,i.jsx)(e.h3,{id:"feedback-linearization",children:"Feedback Linearization"}),"\n",(0,i.jsx)(e.p,{children:"Transform nonlinear dynamics into linear system:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u03c4 = M(q)\u207b\xb9 * (v_d - C(q, q\u0307)q\u0307 - G(q))\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u03c4 = joint torques"}),"\n",(0,i.jsx)(e.li,{children:"M = mass matrix"}),"\n",(0,i.jsx)(e.li,{children:"C = Coriolis matrix"}),"\n",(0,i.jsx)(e.li,{children:"G = gravity vector"}),"\n",(0,i.jsx)(e.li,{children:"v_d = desired acceleration"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hybrid-zero-dynamics-hzd",children:"Hybrid Zero Dynamics (HZD)"}),"\n",(0,i.jsx)(e.p,{children:"Combine continuous dynamics with discrete events (foot impacts):"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u1e8b = f(x) + g(x)u,    if not in contact\r\nx\u207a = \u0394(x),          if in contact\n"})}),"\n",(0,i.jsx)(e.h2,{id:"dynamic-balance-control",children:"Dynamic Balance Control"}),"\n",(0,i.jsx)(e.h3,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Ankle Strategy"}),": Small balance adjustments using ankle torques"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Effective for small disturbances"}),"\n",(0,i.jsx)(e.li,{children:"Low energy consumption"}),"\n",(0,i.jsx)(e.li,{children:"Limited range of effectiveness"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Hip Strategy"}),": Larger adjustments using hip torques"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Effective for medium disturbances"}),"\n",(0,i.jsx)(e.li,{children:"Higher energy consumption"}),"\n",(0,i.jsx)(e.li,{children:"Greater range of effectiveness"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Stepping Strategy"}),": Taking a step to expand support base"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Effective for large disturbances"}),"\n",(0,i.jsx)(e.li,{children:"High energy consumption"}),"\n",(0,i.jsx)(e.li,{children:"Resets balance state"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"multi-level-balance-control",children:"Multi-Level Balance Control"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"High Level"}),": Step planning and gait selection\r\n",(0,i.jsx)(e.strong,{children:"Mid Level"}),": ZMP/Capture Point tracking\r\n",(0,i.jsx)(e.strong,{children:"Low Level"}),": Joint-level control and actuator commands"]}),"\n",(0,i.jsx)(e.h3,{id:"disturbance-rejection",children:"Disturbance Rejection"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Feedforward Compensation"}),": Predict and counteract known disturbances\r\n",(0,i.jsx)(e.strong,{children:"Feedback Control"}),": React to measured disturbances\r\n",(0,i.jsx)(e.strong,{children:"Adaptive Control"}),": Learn and adapt to disturbance patterns"]}),"\n",(0,i.jsx)(e.h2,{id:"technical-depth-mathematical-models",children:"Technical Depth: Mathematical Models"}),"\n",(0,i.jsx)(e.h3,{id:"walking-dynamics",children:"Walking Dynamics"}),"\n",(0,i.jsx)(e.p,{children:"The equation of motion for a bipedal robot:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q) = \u03c4 + J\u1d40F\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"M(q) = mass/inertia matrix"}),"\n",(0,i.jsx)(e.li,{children:"C(q, q\u0307) = Coriolis and centrifugal forces"}),"\n",(0,i.jsx)(e.li,{children:"G(q) = gravitational forces"}),"\n",(0,i.jsx)(e.li,{children:"\u03c4 = joint torques"}),"\n",(0,i.jsx)(e.li,{children:"J = Jacobian matrix"}),"\n",(0,i.jsx)(e.li,{children:"F = external forces"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"linear-inverted-pendulum-model",children:"Linear Inverted Pendulum Model"}),"\n",(0,i.jsx)(e.p,{children:"For ZMP-based control:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u1e8d_com = g/h * (x_com - zmp)\r\n\xff_com = g/h * (y_com - zmp)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"discrete-state-model",children:"Discrete State Model"}),"\n",(0,i.jsx)(e.p,{children:"At foot contact events:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"x(k+1) = A_d * x(k) + B_d * u(k)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsx)(e.h3,{id:"walking-on-different-terrains",children:"Walking on Different Terrains"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Flat Ground"}),": Standard walking patterns\r\n",(0,i.jsx)(e.strong,{children:"Sloped Surfaces"}),": Adjusted body orientation and step parameters\r\n",(0,i.jsx)(e.strong,{children:"Stairs"}),": Specialized climbing/descending gaits\r\n",(0,i.jsx)(e.strong,{children:"Rough Terrain"}),": Adaptive foot placement and balance control\r\n",(0,i.jsx)(e.strong,{children:"Slippery Surfaces"}),": Reduced speed and modified gait patterns"]}),"\n",(0,i.jsx)(e.h3,{id:"speed-control",children:"Speed Control"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Slow Walking"}),": Emphasize stability over speed\r\n",(0,i.jsx)(e.strong,{children:"Normal Walking"}),": Balance between stability and efficiency\r\n",(0,i.jsx)(e.strong,{children:"Fast Walking"}),": Increase step frequency and length\r\n",(0,i.jsx)(e.strong,{children:"Running"}),": Include flight phases (for capable robots)"]}),"\n",(0,i.jsx)(e.h3,{id:"turning-and-maneuvering",children:"Turning and Maneuvering"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Pure Turning"}),": Rotate in place using differential stepping\r\n",(0,i.jsx)(e.strong,{children:"Curved Walking"}),": Combine forward and turning motions\r\n",(0,i.jsx)(e.strong,{children:"Sidestepping"}),": Lateral movement for obstacle avoidance\r\n",(0,i.jsx)(e.strong,{children:"Backward Walking"}),": Reverse locomotion for tight spaces"]}),"\n",(0,i.jsx)(e.h2,{id:"challenges",children:"Challenges"}),"\n",(0,i.jsx)(e.h3,{id:"stability-vs-efficiency",children:"Stability vs. Efficiency"}),"\n",(0,i.jsx)(e.p,{children:"Balancing stable walking with energy efficiency remains challenging."}),"\n",(0,i.jsx)(e.h3,{id:"terrain-adaptation",children:"Terrain Adaptation"}),"\n",(0,i.jsx)(e.p,{children:"Adapting to unknown or changing terrain conditions in real-time."}),"\n",(0,i.jsx)(e.h3,{id:"disturbance-robustness",children:"Disturbance Robustness"}),"\n",(0,i.jsx)(e.p,{children:"Maintaining stable walking despite external disturbances."}),"\n",(0,i.jsx)(e.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,i.jsx)(e.p,{children:"Real-time computation of complex gait patterns and control laws."}),"\n",(0,i.jsx)(e.h2,{id:"figure-list",children:"Figure List"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 8.1"}),": Gait cycle phases and terminology"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 8.2"}),": ZMP and Capture Point concepts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 8.3"}),": Inverted pendulum model visualization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 8.4"}),": Balance control strategy selection"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Figure 8.5"}),": Walking pattern generation flowchart"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"code-example-gait-control-implementation",children:"Code Example: Gait Control Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nfrom typing import List, Tuple, Optional\r\nfrom dataclasses import dataclass\r\nimport matplotlib.pyplot as plt\r\nfrom scipy.integrate import odeint\r\nimport math\r\n\r\n@dataclass\r\nclass GaitPhase:\r\n    """Represents a phase in the gait cycle"""\r\n    name: str\r\n    start_time: float\r\n    end_time: float\r\n    support_leg: str  # \'left\', \'right\', or \'both\'\r\n    duration: float\r\n\r\n@dataclass\r\nclass WalkingState:\r\n    """Current state of the walking robot"""\r\n    com_pos: np.ndarray  # Center of mass position [x, y, z]\r\n    com_vel: np.ndarray  # Center of mass velocity [vx, vy, vz]\r\n    com_acc: np.ndarray  # Center of mass acceleration\r\n    zmp_pos: np.ndarray  # Zero Moment Point [x, y]\r\n    capture_point: np.ndarray  # Capture Point [x, y]\r\n    support_foot_pos: np.ndarray  # Support foot position\r\n    swing_foot_pos: np.ndarray    # Swing foot position\r\n    gait_phase: str\r\n    time_in_phase: float\r\n\r\nclass InvertedPendulumModel:\r\n    """Simple inverted pendulum model for walking"""\r\n\r\n    def __init__(self, height: float = 0.8, gravity: float = 9.81):\r\n        self.height = height\r\n        self.gravity = gravity\r\n        self.omega = np.sqrt(gravity / height)  # Natural frequency\r\n\r\n    def compute_zmp(self, com_pos: np.ndarray, com_acc: np.ndarray) -> np.ndarray:\r\n        """Compute ZMP from CoM position and acceleration"""\r\n        # ZMP = CoM - (h/g) * CoM_acc\r\n        zmp = com_pos[:2] - (self.height / self.gravity) * com_acc[:2]\r\n        return zmp\r\n\r\n    def compute_capture_point(self, com_pos: np.ndarray, com_vel: np.ndarray) -> np.ndarray:\r\n        """Compute capture point from CoM state"""\r\n        # Capture Point = CoM + CoM_vel / omega\r\n        capture_point = com_pos[:2] + com_vel[:2] / self.omega\r\n        return capture_point\r\n\r\n    def integrate_motion(self, zmp_ref: np.ndarray, dt: float,\r\n                        current_com: np.ndarray, current_vel: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\r\n        """Integrate inverted pendulum dynamics"""\r\n        # \u1e8d = \u03c9\xb2 * (x - zmp)\r\n        com_acc = self.omega**2 * (current_com[:2] - zmp_ref)\r\n\r\n        # Update velocity and position\r\n        new_vel = current_vel[:2] + com_acc * dt\r\n        new_pos = current_com[:2] + new_vel * dt + 0.5 * com_acc * dt**2\r\n\r\n        # Return new CoM position (with z unchanged) and velocity\r\n        new_com = np.array([new_pos[0], new_pos[1], current_com[2]])\r\n        new_vel_full = np.array([new_vel[0], new_vel[1], current_vel[2]])\r\n\r\n        return new_com, new_vel_full, np.concatenate([com_acc, np.array([0])])\r\n\r\nclass GaitController:\r\n    """Controller for generating and tracking walking gaits"""\r\n\r\n    def __init__(self, step_length: float = 0.3, step_width: float = 0.2,\r\n                 step_time: float = 0.8, height: float = 0.8):\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n        self.step_time = step_time\r\n        self.inverted_pendulum = InvertedPendulumModel(height=height)\r\n\r\n        # Walking parameters\r\n        self.nominal_zmp_offset = 0.02  # Small offset for stability\r\n        self.capture_point_threshold = 0.1  # When to step\r\n        self.max_step_adjustment = 0.1     # Max adjustment to nominal step\r\n\r\n        # Current walking state\r\n        self.current_state = WalkingState(\r\n            com_pos=np.array([0.0, 0.0, height]),\r\n            com_vel=np.array([0.0, 0.0, 0.0]),\r\n            com_acc=np.array([0.0, 0.0, 0.0]),\r\n            zmp_pos=np.array([0.0, 0.0]),\r\n            capture_point=np.array([0.0, 0.0]),\r\n            support_foot_pos=np.array([0.0, -step_width/2, 0.0]),\r\n            swing_foot_pos=np.array([0.0, step_width/2, 0.0]),\r\n            gait_phase=\'double_support\',\r\n            time_in_phase=0.0\r\n        )\r\n\r\n        self.trajectory_queue = []\r\n        self.is_walking = False\r\n\r\n    def generate_zmp_trajectory(self, walking_speed: float, turn_rate: float = 0.0) -> np.ndarray:\r\n        """Generate reference ZMP trajectory for walking"""\r\n        # Create ZMP trajectory based on walking speed and turn rate\r\n        num_steps = 10  # Plan 10 steps ahead\r\n        dt = 0.01  # 100Hz control\r\n        trajectory_length = int(self.step_time * num_steps / dt)\r\n\r\n        zmp_trajectory = np.zeros((trajectory_length, 2))\r\n\r\n        for i in range(trajectory_length):\r\n            t = i * dt\r\n            step_num = int(t / self.step_time)\r\n\r\n            # Basic ZMP pattern: oscillate around nominal position\r\n            nominal_x = walking_speed * t\r\n            nominal_y = turn_rate * t * self.step_width  # Simplified turning\r\n\r\n            # Add small oscillations for stability\r\n            oscillation = 0.01 * np.sin(2 * np.pi * t / self.step_time)\r\n\r\n            zmp_trajectory[i, 0] = nominal_x + oscillation\r\n            zmp_trajectory[i, 1] = nominal_y + self.nominal_zmp_offset\r\n\r\n        return zmp_trajectory\r\n\r\n    def compute_foot_placement(self, current_support_foot: np.ndarray,\r\n                             is_left_support: bool) -> np.ndarray:\r\n        """Compute next foot placement based on current state"""\r\n        # Calculate desired foot placement\r\n        # This is a simplified version - in reality, this would consider balance state\r\n\r\n        # Nominal step location\r\n        if is_left_support:\r\n            # Right foot should go forward and slightly inward\r\n            dx = self.step_length\r\n            dy = -self.step_width if self.current_state.gait_phase == \'left_swing\' else self.step_width\r\n        else:\r\n            # Left foot should go forward and slightly inward\r\n            dx = self.step_length\r\n            dy = self.step_width if self.current_state.gait_phase == \'right_swing\' else -self.step_width\r\n\r\n        # Adjust for balance state (if capture point is far from support foot)\r\n        capture_to_foot = self.current_state.capture_point - current_support_foot[:2]\r\n        distance_to_capture = np.linalg.norm(capture_to_foot)\r\n\r\n        if distance_to_capture > self.capture_point_threshold:\r\n            # Step toward capture point\r\n            direction = capture_to_foot / distance_to_capture\r\n            adjustment = min(self.max_step_adjustment, distance_to_capture - self.capture_point_threshold)\r\n            dx += direction[0] * adjustment\r\n            dy += direction[1] * adjustment\r\n\r\n        new_foot_pos = current_support_foot.copy()\r\n        new_foot_pos[0] += dx\r\n        new_foot_pos[1] += dy\r\n\r\n        return new_foot_pos\r\n\r\n    def generate_swing_foot_trajectory(self, start_pos: np.ndarray,\r\n                                     end_pos: np.ndarray, phase: float) -> np.ndarray:\r\n        """Generate smooth trajectory for swing foot"""\r\n        # Use 3rd order polynomial for smooth lift and place\r\n        # Phase from 0 (lift) to 1 (place)\r\n\r\n        # Horizontal interpolation\r\n        x = start_pos[0] + phase * (end_pos[0] - start_pos[0])\r\n        y = start_pos[1] + phase * (end_pos[1] - start_pos[1])\r\n\r\n        # Vertical trajectory (parabolic lift and place)\r\n        # Maximum height at phase = 0.5\r\n        vertical_phase = 4 * phase * (1 - phase)  # Parabolic profile\r\n        z = start_pos[2] + 0.05 * vertical_phase  # 5cm maximum lift\r\n\r\n        return np.array([x, y, z])\r\n\r\n    def update_walking_state(self, dt: float, walking_speed: float = 0.1) -> WalkingState:\r\n        """Update walking state based on control inputs"""\r\n        # Generate reference ZMP\r\n        zmp_ref = self.generate_zmp_trajectory(walking_speed)[int(self.current_state.time_in_phase/dt), :]\r\n\r\n        # Integrate inverted pendulum dynamics\r\n        new_com, new_vel, new_acc = self.inverted_pendulum.integrate_motion(\r\n            zmp_ref, dt, self.current_state.com_pos, self.current_state.com_vel\r\n        )\r\n\r\n        # Update capture point\r\n        capture_point = self.inverted_pendulum.compute_capture_point(new_com, new_vel)\r\n\r\n        # Update ZMP (from actual CoM state)\r\n        zmp = self.inverted_pendulum.compute_zmp(new_com, new_acc)\r\n\r\n        # Update gait phase based on time\r\n        self.current_state.time_in_phase += dt\r\n        if self.current_state.time_in_phase >= self.step_time:\r\n            self.current_state.time_in_phase = 0.0\r\n            # Switch support leg\r\n            if self.current_state.gait_phase == \'left_swing\':\r\n                self.current_state.gait_phase = \'right_swing\'\r\n            else:\r\n                self.current_state.gait_phase = \'left_swing\'\r\n\r\n        # Update support and swing feet positions\r\n        is_left_support = self.current_state.gait_phase == \'right_swing\'\r\n\r\n        # Compute next foot placement\r\n        support_foot = self.current_state.support_foot_pos.copy()\r\n        if is_left_support:\r\n            # Right foot is swing foot, compute next right foot placement\r\n            self.current_state.swing_foot_pos = self.compute_foot_placement(\r\n                self.current_state.support_foot_pos, not is_left_support\r\n            )\r\n        else:\r\n            # Left foot is swing foot, compute next left foot placement\r\n            self.current_state.support_foot_pos = self.compute_foot_placement(\r\n                self.current_state.swing_foot_pos, is_left_support\r\n            )\r\n\r\n        # Update current state\r\n        self.current_state.com_pos = new_com\r\n        self.current_state.com_vel = new_vel\r\n        self.current_state.com_acc = new_acc\r\n        self.current_state.zmp_pos = zmp\r\n        self.current_state.capture_point = capture_point\r\n\r\n        return self.current_state\r\n\r\n    def start_walking(self, walking_speed: float = 0.1):\r\n        """Initialize walking motion"""\r\n        self.is_walking = True\r\n        self.trajectory_queue = []\r\n        # Initialize with basic walking parameters\r\n        self.current_state.gait_phase = \'left_swing\'\r\n\r\n    def stop_walking(self):\r\n        """Stop walking motion"""\r\n        self.is_walking = False\r\n        # Implement stopping strategy (e.g., capture point approach)\r\n        self.slow_down()\r\n\r\nclass BalanceController:\r\n    """Balance controller that works with gait controller"""\r\n\r\n    def __init__(self, pendulum_model: InvertedPendulumModel):\r\n        self.pendulum_model = pendulum_model\r\n        self.k_p = 10.0  # Position gain\r\n        self.k_d = 2.0   # Velocity gain\r\n\r\n    def compute_balance_correction(self, desired_zmp: np.ndarray,\r\n                                 actual_zmp: np.ndarray) -> np.ndarray:\r\n        """Compute balance correction based on ZMP error"""\r\n        zmp_error = desired_zmp - actual_zmp\r\n        correction = self.k_p * zmp_error\r\n        return correction\r\n\r\n    def compute_ankle_torque(self, com_pos: np.ndarray, com_vel: np.ndarray,\r\n                           zmp_ref: np.ndarray) -> np.ndarray:\r\n        """Compute ankle torques for balance"""\r\n        # Simple model: ankle torques proportional to ZMP error\r\n        actual_zmp = self.pendulum_model.compute_zmp(com_pos, np.zeros(3))\r\n        zmp_error = zmp_ref - actual_zmp\r\n\r\n        # Map ZMP error to ankle torques\r\n        ankle_torque = np.array([zmp_error[1] * 50, -zmp_error[0] * 50, 0])  # Simplified\r\n\r\n        return ankle_torque\r\n\r\nclass WalkingPatternGenerator:\r\n    """Generate complete walking patterns"""\r\n\r\n    def __init__(self, gait_controller: GaitController):\r\n        self.gait_controller = gait_controller\r\n\r\n    def generate_omni_directional_walk(self, speed: float, direction: float,\r\n                                     turn_rate: float) -> List[np.ndarray]:\r\n        """Generate omni-directional walking pattern"""\r\n        # direction in radians (0 = forward, \u03c0/2 = left, etc.)\r\n        x_speed = speed * np.cos(direction)\r\n        y_speed = speed * np.sin(direction)\r\n\r\n        # Generate pattern for specified parameters\r\n        steps = []\r\n        dt = 0.01\r\n\r\n        for i in range(int(5 / dt)):  # 5 seconds of walking\r\n            state = self.gait_controller.update_walking_state(dt, x_speed)\r\n            steps.append(state.com_pos.copy())\r\n\r\n        return steps\r\n\r\n    def generate_stair_climbing_pattern(self, step_height: float = 0.15) -> List[np.ndarray]:\r\n        """Generate pattern for stair climbing"""\r\n        # Simplified stair climbing pattern\r\n        pattern = []\r\n\r\n        # For each step, generate lift, place, and shift pattern\r\n        for step in range(5):  # 5 steps up\r\n            # Lift CoM\r\n            for i in range(10):\r\n                t = i / 10\r\n                height = step * step_height + t * step_height\r\n                pattern.append(np.array([step * 0.3, 0, height + 0.8]))\r\n\r\n            # Shift weight\r\n            for i in range(20):\r\n                pattern.append(np.array([(step + 0.5) * 0.3, 0, (step + 1) * step_height + 0.8]))\r\n\r\n        return pattern\r\n\r\ndef simulate_walking_trial():\r\n    """Simulate a walking trial with the controllers"""\r\n    print("Walking Simulation Trial")\r\n    print("=" * 30)\r\n\r\n    # Initialize controllers\r\n    gait_controller = GaitController(step_length=0.3, step_width=0.2, step_time=0.8, height=0.8)\r\n    balance_controller = BalanceController(gait_controller.inverted_pendulum)\r\n    pattern_generator = WalkingPatternGenerator(gait_controller)\r\n\r\n    print(f"1. Controller initialized with:")\r\n    print(f"   - Step length: {gait_controller.step_length}m")\r\n    print(f"   - Step width: {gait_controller.step_width}m")\r\n    print(f"   - Step time: {gait_controller.step_time}s")\r\n    print(f"   - CoM height: {gait_controller.inverted_pendulum.height}m")\r\n\r\n    # Start walking\r\n    gait_controller.start_walking(walking_speed=0.1)\r\n    print(f"\\n2. Walking started with speed: 0.1 m/s")\r\n\r\n    # Simulate walking for a few seconds\r\n    dt = 0.01  # 100Hz control\r\n    simulation_time = 3.0  # 3 seconds\r\n    steps = int(simulation_time / dt)\r\n\r\n    com_positions = []\r\n    zmp_positions = []\r\n    capture_points = []\r\n\r\n    for i in range(steps):\r\n        state = gait_controller.update_walking_state(dt)\r\n\r\n        # Store trajectory data\r\n        com_positions.append(state.com_pos.copy())\r\n        zmp_positions.append(state.zmp_pos.copy())\r\n        capture_points.append(state.capture_point.copy())\r\n\r\n    print(f"3. Simulated {steps} control cycles ({simulation_time}s)")\r\n    print(f"   Final CoM position: [{state.com_pos[0]:.3f}, {state.com_pos[1]:.3f}, {state.com_pos[2]:.3f}]")\r\n    print(f"   Final ZMP: [{state.zmp_pos[0]:.3f}, {state.zmp_pos[1]:.3f}]")\r\n    print(f"   Final Capture Point: [{state.capture_point[0]:.3f}, {state.capture_point[1]:.3f}]")\r\n\r\n    # Analyze stability\r\n    com_path = np.array(com_positions)\r\n    zmp_path = np.array(zmp_positions)\r\n\r\n    # Calculate average CoM height maintenance\r\n    height_variation = np.std(com_path[:, 2])\r\n    print(f"4. Stability metrics:")\r\n    print(f"   - CoM height std: {height_variation:.3f}m")\r\n    print(f"   - Average forward progress: {com_path[-1, 0]:.3f}m")\r\n    print(f"   - Average lateral deviation: {np.mean(np.abs(com_path[:, 1])):.3f}m")\r\n\r\n    # Calculate ZMP tracking error\r\n    zmp_error = np.mean(np.linalg.norm(zmp_path - com_path[:, :2] + np.array([0.02, 0]), axis=1))\r\n    print(f"   - Average ZMP tracking error: {zmp_error:.3f}m")\r\n\r\n    # Generate omni-directional walk\r\n    print(f"\\n5. Omni-directional walking:")\r\n    directions = [0, np.pi/4, np.pi/2]  # Forward, diagonal, sideways\r\n    for direction in directions:\r\n        x_speed = 0.1 * np.cos(direction)\r\n        y_speed = 0.1 * np.sin(direction)\r\n        print(f"   - Direction {direction:.2f} rad: [{x_speed:.3f}, {y_speed:.3f}] m/s")\r\n\r\n    # Test balance controller\r\n    print(f"\\n6. Balance control test:")\r\n    test_zmp_ref = np.array([0.1, 0.05])\r\n    balance_correction = balance_controller.compute_balance_correction(\r\n        test_zmp_ref, state.zmp_pos\r\n    )\r\n    ankle_torque = balance_controller.compute_ankle_torque(\r\n        state.com_pos, state.com_vel, test_zmp_ref\r\n    )\r\n    print(f"   - ZMP reference: [{test_zmp_ref[0]:.3f}, {test_zmp_ref[1]:.3f}]")\r\n    print(f"   - Balance correction: [{balance_correction[0]:.3f}, {balance_correction[1]:.3f}]")\r\n    print(f"   - Ankle torque: [{ankle_torque[0]:.3f}, {ankle_torque[1]:.3f}, {ankle_torque[2]:.3f}]")\r\n\r\n    # Generate stair climbing pattern\r\n    print(f"\\n7. Stair climbing pattern:")\r\n    stair_pattern = pattern_generator.generate_stair_climbing_pattern()\r\n    print(f"   - Generated {len(stair_pattern)} steps for stair climbing")\r\n    print(f"   - Final height: {stair_pattern[-1][2]:.3f}m")\r\n\r\n    return com_positions, zmp_positions, capture_points\r\n\r\ndef analyze_locomotion_performance(com_positions: List[np.ndarray],\r\n                                 zmp_positions: List[np.ndarray]) -> dict:\r\n    """Analyze locomotion performance metrics"""\r\n    com_path = np.array(com_positions)\r\n    zmp_path = np.array(zmp_positions)\r\n\r\n    metrics = {}\r\n\r\n    # Stability metrics\r\n    metrics[\'avg_height\'] = np.mean(com_path[:, 2])\r\n    metrics[\'height_std\'] = np.std(com_path[:, 2])\r\n    metrics[\'forward_progress\'] = com_path[-1, 0] - com_path[0, 0]\r\n    metrics[\'avg_speed\'] = metrics[\'forward_progress\'] / len(com_path) * 100  # Assuming 100Hz\r\n\r\n    # Balance metrics\r\n    # Calculate ZMP stability margin (distance from support polygon boundary)\r\n    # For simplicity, assume square support polygon around foot\r\n    support_size = 0.1  # 10cm support area\r\n    zmp_stability = []\r\n    for i, (com_pos, zmp_pos) in enumerate(zip(com_path, zmp_path)):\r\n        # Distance from ZMP to CoM projection (simplified stability measure)\r\n        stability_margin = support_size - np.linalg.norm(zmp_pos - com_pos[:2])\r\n        zmp_stability.append(max(0, stability_margin))  # Only positive margins\r\n\r\n    metrics[\'avg_stability_margin\'] = np.mean(zmp_stability)\r\n    metrics[\'min_stability_margin\'] = min(zmp_stability) if zmp_stability else 0\r\n\r\n    # Efficiency metrics\r\n    metrics[\'path_efficiency\'] = metrics[\'forward_progress\'] / np.sum(\r\n        np.linalg.norm(np.diff(com_path, axis=0), axis=1)\r\n    ) if len(com_path) > 1 else 0\r\n\r\n    # Smoothness metrics\r\n    velocities = np.linalg.norm(np.diff(com_path, axis=0), axis=1)\r\n    metrics[\'speed_variation\'] = np.std(velocities) / (np.mean(velocities) + 1e-6)\r\n\r\n    return metrics\r\n\r\nif __name__ == "__main__":\r\n    # Run the simulation\r\n    com_positions, zmp_positions, capture_points = simulate_walking_trial()\r\n\r\n    # Analyze performance\r\n    performance_metrics = analyze_locomotion_performance(com_positions, zmp_positions)\r\n\r\n    print(f"\\n8. Performance Analysis:")\r\n    for metric, value in performance_metrics.items():\r\n        print(f"   - {metric}: {value:.3f}")\r\n\r\n    print(f"\\nLocomotion and Gait Control - Chapter 8 Complete!")\n'})}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Implement a simple ZMP controller for a 2D inverted pendulum and simulate walking."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Design a gait pattern that allows a humanoid robot to walk up a ramp with a 15-degree incline."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Create a balance controller that uses both ankle and hip strategies based on disturbance magnitude."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary-1",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter provided a comprehensive overview of locomotion and gait control for humanoid robots, covering the fundamental principles of bipedal walking, ZMP control, capture point dynamics, and practical implementation strategies. We explored mathematical models, control algorithms, and the integration of balance control with locomotion. The concepts and code examples presented will help in developing robust walking controllers for humanoid robots that can navigate real-world environments safely and efficiently."})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>l});var t=r(6540);const i={},o=t.createContext(i);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);