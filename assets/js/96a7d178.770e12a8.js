"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[694],{8269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>_,frontMatter:()=>a,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"tutorials/basic-control-examples/simple-locomotion","title":"Simple Locomotion","description":"Overview","source":"@site/docs/tutorials/basic-control-examples/simple-locomotion.md","sourceDirName":"tutorials/basic-control-examples","slug":"/tutorials/basic-control-examples/simple-locomotion","permalink":"/AI-Robotics-Book/docs/tutorials/basic-control-examples/simple-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/tutorials/basic-control-examples/simple-locomotion.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4}}');var s=n(4848),o=n(8453);const a={sidebar_position:4},i="Simple Locomotion",l={},p=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Locomotion Fundamentals",id:"locomotion-fundamentals",level:2},{value:"Gait Cycle Phases",id:"gait-cycle-phases",level:3},{value:"Inverted Pendulum Walking Model",id:"inverted-pendulum-walking-model",level:2},{value:"ZMP-Based Walking Controller",id:"zmp-based-walking-controller",level:2},{value:"Simple Stepping Pattern",id:"simple-stepping-pattern",level:2},{value:"Walk Pattern Generator",id:"walk-pattern-generator",level:2},{value:"Practical Walking Controller",id:"practical-walking-controller",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercises",id:"exercises",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"simple-locomotion",children:"Simple Locomotion"})}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"Locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control systems to maintain balance while moving. This tutorial covers fundamental locomotion concepts including gait generation, ZMP-based walking, and basic stepping patterns."}),"\n",(0,s.jsx)(t.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(t.p,{children:"By the end of this tutorial, you will be able to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Understand the basics of bipedal locomotion"}),"\n",(0,s.jsx)(t.li,{children:"Generate simple walking patterns"}),"\n",(0,s.jsx)(t.li,{children:"Implement ZMP-based walking control"}),"\n",(0,s.jsx)(t.li,{children:"Create basic stepping and balance recovery patterns"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"locomotion-fundamentals",children:"Locomotion Fundamentals"}),"\n",(0,s.jsx)(t.h3,{id:"gait-cycle-phases",children:"Gait Cycle Phases"}),"\n",(0,s.jsx)(t.p,{children:"Bipedal locomotion consists of several phases:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stance Phase"}),": When the foot is in contact with the ground"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Swing Phase"}),": When the foot is off the ground moving forward"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Double Support Phase"}),": When both feet are in contact"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Single Support Phase"}),": When only one foot is in contact"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nclass GaitPhase:\r\n    """Represents a phase in the gait cycle"""\r\n    def __init__(self, name, start_time, end_time, support_leg):\r\n        self.name = name\r\n        self.start_time = start_time\r\n        self.end_time = end_time\r\n        self.support_leg = support_leg  # \'left\', \'right\', or \'both\'\r\n        self.duration = end_time - start_time\r\n\r\nclass GaitGenerator:\r\n    """Generate basic walking gaits"""\r\n    def __init__(self, step_length=0.3, step_width=0.2, step_time=0.8):\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n        self.step_time = step_time\r\n        self.gait_phases = self._generate_gait_phases()\r\n\r\n    def _generate_gait_phases(self):\r\n        """Generate the phases of a basic walking gait"""\r\n        phases = []\r\n\r\n        # Single support phase - left foot supports, right foot swings\r\n        phases.append(GaitPhase("Left Support", 0, self.step_time/2, "left"))\r\n\r\n        # Double support phase - both feet on ground\r\n        phases.append(GaitPhase("Double Support", self.step_time/2, self.step_time/2 + 0.05, "both"))\r\n\r\n        # Single support phase - right foot supports, left foot swings\r\n        phases.append(GaitPhase("Right Support", self.step_time/2 + 0.05, self.step_time, "right"))\r\n\r\n        return phases\r\n\r\n    def get_current_phase(self, time):\r\n        """Get the current gait phase based on time"""\r\n        cycle_time = time % self.step_time\r\n        for phase in self.gait_phases:\r\n            if phase.start_time <= cycle_time <= phase.end_time:\r\n                return phase\r\n        return self.gait_phases[-1]  # Return last phase if none match\r\n\r\n    def generate_foot_trajectory(self, start_pos, step_num, side="left"):\r\n        """Generate foot trajectory for a step"""\r\n        # Define key points in the foot trajectory\r\n        lift_height = 0.05  # 5cm lift\r\n\r\n        # Start position\r\n        start_x = start_pos[0] + (step_num * self.step_length)\r\n        start_y = start_pos[1] + (self.step_width if side == "right" else -self.step_width)\r\n\r\n        # End position (next step)\r\n        end_x = start_x + self.step_length\r\n        end_y = start_pos[1] + (-self.step_width if side == "right" else self.step_width)\r\n\r\n        # Generate trajectory points\r\n        t = np.linspace(0, 1, 50)\r\n\r\n        # X trajectory (smooth interpolation)\r\n        x_traj = start_x + (end_x - start_x) * t\r\n\r\n        # Y trajectory (return to center line)\r\n        y_traj = start_y + (end_y - start_y) * t\r\n\r\n        # Z trajectory (parabolic lift and place)\r\n        z_lift = 4 * lift_height * t * (1 - t)  # Parabolic curve\r\n\r\n        return np.column_stack([x_traj, y_traj, z_lift])\r\n\r\n# Example usage\r\ngait_gen = GaitGenerator(step_length=0.3, step_width=0.15, step_time=0.8)\r\ncurrent_phase = gait_gen.get_current_phase(0.4)\r\nprint(f"Current phase at t=0.4s: {current_phase.name}, support: {current_phase.support_leg}")\n'})}),"\n",(0,s.jsx)(t.h2,{id:"inverted-pendulum-walking-model",children:"Inverted Pendulum Walking Model"}),"\n",(0,s.jsx)(t.p,{children:"The linear inverted pendulum is a fundamental model for walking:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class LinearInvertedPendulum:\r\n    """Linear inverted pendulum model for walking"""\r\n    def __init__(self, height=0.8, gravity=9.81):\r\n        self.height = height\r\n        self.gravity = gravity\r\n        self.omega = np.sqrt(gravity / height)\r\n\r\n    def compute_com_trajectory(self, zmp_trajectory, dt=0.005):\r\n        """Compute CoM trajectory from ZMP reference"""\r\n        n_steps = len(zmp_trajectory)\r\n        com_trajectory = np.zeros((n_steps, 3))\r\n        com_velocity = np.zeros((n_steps, 3))\r\n\r\n        # Initial conditions\r\n        com_trajectory[0] = [0, 0, self.height]\r\n        com_velocity[0] = [0, 0, 0]\r\n\r\n        # Integrate inverted pendulum dynamics\r\n        for i in range(1, n_steps):\r\n            # \u1e8d = \u03c9\xb2 * (x - zmp)\r\n            com_acc = self.omega**2 * (com_trajectory[i-1, :2] - zmp_trajectory[i])\r\n            com_acc_full = np.append(com_acc, [0])  # No vertical acceleration\r\n\r\n            # Update velocity and position\r\n            com_velocity[i] = com_velocity[i-1] + com_acc_full * dt\r\n            com_trajectory[i] = com_trajectory[i-1] + com_velocity[i] * dt + 0.5 * com_acc_full * dt**2\r\n\r\n            # Keep constant height\r\n            com_trajectory[i, 2] = self.height\r\n\r\n        return com_trajectory, com_velocity\r\n\r\n    def compute_zmp_from_com(self, com_pos, com_acc):\r\n        """Compute ZMP from CoM state"""\r\n        zmp_x = com_pos[0] - (com_acc[0] * self.height / self.gravity)\r\n        zmp_y = com_pos[1] - (com_acc[1] * self.height / self.gravity)\r\n        return np.array([zmp_x, zmp_y])\n'})}),"\n",(0,s.jsx)(t.h2,{id:"zmp-based-walking-controller",children:"ZMP-Based Walking Controller"}),"\n",(0,s.jsx)(t.p,{children:"Implementing a ZMP-based walking controller:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class ZMPWalkingController:\r\n    """ZMP-based walking controller"""\r\n    def __init__(self, com_height=0.8, gravity=9.81):\r\n        self.com_height = com_height\r\n        self.gravity = gravity\r\n        self.omega = np.sqrt(gravity / com_height)\r\n\r\n        # Walking parameters\r\n        self.step_length = 0.3\r\n        self.step_width = 0.15\r\n        self.step_time = 0.8\r\n        self.zmp_reference_offset = 0.02  # Small offset for stability\r\n\r\n        # PID controller for ZMP tracking\r\n        self.zmp_x_pid = PIDController(kp=50.0, ki=5.0, kd=10.0)\r\n        self.zmp_y_pid = PIDController(kp=50.0, ki=5.0, kd=10.0)\r\n\r\n        # Foot placement variables\r\n        self.left_foot_pos = np.array([0.0, self.step_width, 0.0])\r\n        self.right_foot_pos = np.array([0.0, -self.step_width, 0.0])\r\n        self.next_foot_placement = "left"\r\n        self.step_count = 0\r\n\r\n        # Walking state\r\n        self.is_walking = False\r\n        self.walk_time = 0.0\r\n\r\n    def start_walking(self, step_length=0.3, step_width=0.15, step_time=0.8):\r\n        """Initialize walking with given parameters"""\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n        self.step_time = step_time\r\n        self.is_walking = True\r\n        self.walk_time = 0.0\r\n        self.step_count = 0\r\n\r\n    def generate_zmp_trajectory(self, walk_time):\r\n        """Generate reference ZMP trajectory for walking"""\r\n        # Create a periodic ZMP pattern\r\n        cycle_time = walk_time % (self.step_time * 2)  # Two steps per cycle\r\n\r\n        # Basic ZMP pattern: oscillate around nominal position\r\n        nominal_x = (self.step_count + cycle_time / (self.step_time * 2)) * self.step_length\r\n\r\n        # Add small oscillations for stability\r\n        oscillation = 0.01 * np.sin(2 * np.pi * cycle_time / self.step_time)\r\n\r\n        # Y position alternates between feet\r\n        if self.next_foot_placement == "left":\r\n            nominal_y = -self.zmp_reference_offset\r\n        else:\r\n            nominal_y = self.zmp_reference_offset\r\n\r\n        return np.array([nominal_x, nominal_y])\r\n\r\n    def update_walking(self, current_com, current_com_vel, dt):\r\n        """Update walking controller"""\r\n        if not self.is_walking:\r\n            return np.zeros(6)  # No torques when not walking\r\n\r\n        # Update timing\r\n        self.walk_time += dt\r\n\r\n        # Generate reference ZMP\r\n        zmp_ref = self.generate_zmp_trajectory(self.walk_time)\r\n\r\n        # Compute current ZMP\r\n        com_acc = self.estimate_com_acceleration(current_com, current_com_vel, dt)\r\n        current_zmp = self.compute_zmp_from_com(current_com, com_acc)\r\n\r\n        # Compute ZMP error and required torques\r\n        zmp_error = zmp_ref - current_zmp[:2]\r\n\r\n        # Use PID controllers to compute corrective torques\r\n        torque_x = self.zmp_x_pid.update(zmp_ref[0], current_zmp[0], dt)\r\n        torque_y = self.zmp_y_pid.update(zmp_ref[1], current_zmp[1], dt)\r\n\r\n        # Map to joint torques (simplified mapping)\r\n        joint_torques = self.map_zmp_torques_to_joints(torque_x, torque_y)\r\n\r\n        # Check for step timing\r\n        self.check_step_timing(current_com)\r\n\r\n        return joint_torques\r\n\r\n    def estimate_com_acceleration(self, current_com, current_com_vel, dt):\r\n        """Estimate CoM acceleration from velocity"""\r\n        # This would typically come from a state estimator\r\n        # For now, we\'ll use a simple backward difference\r\n        if not hasattr(self, \'prev_vel\'):\r\n            self.prev_vel = current_com_vel.copy()\r\n            return np.zeros(3)\r\n\r\n        com_acc = (current_com_vel - self.prev_vel) / dt\r\n        self.prev_vel = current_com_vel.copy()\r\n        return com_acc\r\n\r\n    def compute_zmp_from_com(self, com_pos, com_acc):\r\n        """Compute ZMP from CoM state"""\r\n        zmp_x = com_pos[0] - (com_acc[0] * self.com_height / self.gravity)\r\n        zmp_y = com_pos[1] - (com_acc[1] * self.com_height / self.gravity)\r\n        return np.array([zmp_x, zmp_y, 0])\r\n\r\n    def map_zmp_torques_to_joints(self, torque_x, torque_y):\r\n        """Map ZMP torques to joint torques (simplified)"""\r\n        # This is a simplified mapping - in reality, this would involve\r\n        # whole-body control and inverse dynamics\r\n        torques = np.zeros(6)  # 6-DOF torques at base\r\n\r\n        # Map X torque to hip pitch\r\n        torques[3] = torque_x * 50  # Scale factor\r\n\r\n        # Map Y torque to hip roll\r\n        torques[4] = -torque_y * 50  # Scale factor\r\n\r\n        return torques\r\n\r\n    def check_step_timing(self, current_com):\r\n        """Check if it\'s time to take the next step"""\r\n        cycle_time = self.walk_time % self.step_time\r\n\r\n        # Take step when we reach the end of the step phase\r\n        if (cycle_time < self.step_time / 4 or  # Beginning of new step phase\r\n            (self.walk_time // self.step_time) > self.step_count):  # New step interval\r\n\r\n            new_step_count = int(self.walk_time // self.step_time)\r\n            if new_step_count > self.step_count:\r\n                self.step_count = new_step_count\r\n                # Place next foot\r\n                if self.next_foot_placement == "left":\r\n                    self.left_foot_pos = np.array([\r\n                        self.step_count * self.step_length,\r\n                        self.step_width,\r\n                        0.0\r\n                    ])\r\n                    self.next_foot_placement = "right"\r\n                else:\r\n                    self.right_foot_pos = np.array([\r\n                        self.step_count * self.step_length,\r\n                        -self.step_width,\r\n                        0.0\r\n                    ])\r\n                    self.next_foot_placement = "left"\r\n\r\n    def stop_walking(self):\r\n        """Stop walking motion"""\r\n        self.is_walking = False\r\n        # Implement stopping strategy (e.g., capture point approach)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"simple-stepping-pattern",children:"Simple Stepping Pattern"}),"\n",(0,s.jsx)(t.p,{children:"Creating basic stepping patterns for balance recovery:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class SteppingPatternGenerator:\r\n    """Generate stepping patterns for balance recovery"""\r\n    def __init__(self, step_length=0.3, step_width=0.15):\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n\r\n    def compute_capture_point(self, com_pos, com_vel, com_height=0.8, gravity=9.81):\r\n        """Compute capture point from CoM state"""\r\n        omega = np.sqrt(gravity / com_height)\r\n        capture_point = com_pos[:2] + com_vel[:2] / omega\r\n        return capture_point\r\n\r\n    def generate_recovery_step(self, current_support_pos, com_state, strategy="capture_point"):\r\n        """Generate a recovery step based on current state"""\r\n        com_pos = com_state[\'position\']\r\n        com_vel = com_state[\'velocity\']\r\n        com_height = com_state.get(\'height\', 0.8)\r\n\r\n        if strategy == "capture_point":\r\n            # Place foot at or beyond capture point\r\n            capture_point = self.compute_capture_point(com_pos, com_vel, com_height)\r\n\r\n            # Ensure step is in a reasonable direction\r\n            step_direction = capture_point - current_support_pos[:2]\r\n            step_distance = np.linalg.norm(step_direction)\r\n\r\n            # Limit step size\r\n            max_step = self.step_length * 1.5  # 1.5x normal step\r\n            if step_distance > max_step:\r\n                step_direction = step_direction / step_distance * max_step\r\n\r\n            step_pos = current_support_pos.copy()\r\n            step_pos[:2] = current_support_pos[:2] + step_direction\r\n\r\n            return step_pos\r\n\r\n        elif strategy == "directional":\r\n            # Step in the direction opposite to CoM offset\r\n            com_offset = com_pos[:2] - current_support_pos[:2]\r\n            step_direction = -com_offset\r\n            step_distance = np.linalg.norm(step_direction)\r\n\r\n            # Normalize and scale\r\n            if step_distance > 0:\r\n                step_direction = step_direction / step_distance\r\n                step_size = min(step_distance * 1.2, self.step_length * 1.5)\r\n                step_direction *= step_size\r\n\r\n            step_pos = current_support_pos.copy()\r\n            step_pos[:2] = current_support_pos[:2] + step_direction\r\n\r\n            return step_pos\r\n\r\n    def generate_omni_directional_step(self, direction, distance=None):\r\n        """Generate a step in any direction"""\r\n        if distance is None:\r\n            distance = self.step_length\r\n\r\n        step_x = distance * np.cos(direction)\r\n        step_y = distance * np.sin(direction)\r\n\r\n        return np.array([step_x, step_y, 0.0])\r\n\r\n# Example: Recovery step generation\r\nrecovery_gen = SteppingPatternGenerator()\r\ncurrent_support = np.array([0.0, 0.1, 0.0])  # Left foot position\r\ncom_state = {\r\n    \'position\': np.array([0.1, 0.15, 0.8]),\r\n    \'velocity\': np.array([0.05, 0.02, 0.0]),\r\n    \'height\': 0.8\r\n}\r\n\r\nrecovery_step = recovery_gen.generate_recovery_step(current_support, com_state)\r\nprint(f"Recovery step position: {recovery_step}")\n'})}),"\n",(0,s.jsx)(t.h2,{id:"walk-pattern-generator",children:"Walk Pattern Generator"}),"\n",(0,s.jsx)(t.p,{children:"Creating complete walk patterns:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class WalkPatternGenerator:\r\n    \"\"\"Generate complete walking patterns\"\"\"\r\n    def __init__(self, step_length=0.3, step_width=0.15, step_time=0.8):\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n        self.step_time = step_time\r\n        self.stepping_gen = SteppingPatternGenerator(step_length, step_width)\r\n\r\n    def generate_walk_pattern(self, num_steps, start_pos=np.array([0, 0, 0.8])):\r\n        \"\"\"Generate a complete walk pattern\"\"\"\r\n        pattern = {\r\n            'com_trajectory': [],\r\n            'left_foot_trajectory': [],\r\n            'right_foot_trajectory': [],\r\n            'zmp_trajectory': [],\r\n            'timestamps': []\r\n        }\r\n\r\n        # Initial positions\r\n        left_foot = start_pos + np.array([0, self.step_width, 0])\r\n        right_foot = start_pos + np.array([0, -self.step_width, 0])\r\n\r\n        com_pos = start_pos.copy()\r\n        com_vel = np.array([0, 0, 0])\r\n\r\n        dt = 0.005  # 200 Hz\r\n        time = 0\r\n\r\n        for step in range(num_steps):\r\n            # Simulate one step cycle\r\n            step_duration = self.step_time\r\n            steps_in_cycle = int(step_duration / dt)\r\n\r\n            for i in range(steps_in_cycle):\r\n                t = i * dt\r\n\r\n                # Simple forward progression\r\n                com_pos[0] = start_pos[0] + (step + t/self.step_time) * self.step_length\r\n                com_pos[1] = start_pos[1] + (-1)**step * 0.02 * np.sin(2*np.pi*t/self.step_time)  # Small lateral sway\r\n\r\n                # Foot trajectories\r\n                if step % 2 == 0:  # Left foot swings\r\n                    left_x = step * self.step_length + t/self.step_time * self.step_length\r\n                    left_y = self.step_width * (1 - t/self.step_time)  # Return to center\r\n                    left_foot = np.array([left_x, left_y, 0])\r\n                    right_foot = np.array([(step+1) * self.step_length, -self.step_width, 0])\r\n                else:  # Right foot swings\r\n                    right_x = step * self.step_length + t/self.step_time * self.step_length\r\n                    right_y = -self.step_width * (1 - t/self.step_time)  # Return to center\r\n                    right_foot = np.array([right_x, right_y, 0])\r\n                    left_foot = np.array([step * self.step_length, self.step_width, 0])\r\n\r\n                # Calculate ZMP (simplified)\r\n                zmp = np.array([com_pos[0] - 0.02, com_pos[1]])  # Small offset\r\n\r\n                # Store data\r\n                pattern['com_trajectory'].append(com_pos.copy())\r\n                pattern['left_foot_trajectory'].append(left_foot.copy())\r\n                pattern['right_foot_trajectory'].append(right_foot.copy())\r\n                pattern['zmp_trajectory'].append(zmp.copy())\r\n                pattern['timestamps'].append(time)\r\n\r\n                time += dt\r\n\r\n        # Convert to numpy arrays\r\n        for key in pattern:\r\n            if key != 'timestamps':\r\n                pattern[key] = np.array(pattern[key])\r\n\r\n        return pattern\r\n\r\n    def generate_turning_pattern(self, angle, turn_radius=0.5):\r\n        \"\"\"Generate a turning walking pattern\"\"\"\r\n        # Calculate number of steps needed for turn\r\n        arc_length = turn_radius * abs(angle)\r\n        num_steps = int(arc_length / self.step_length) + 1\r\n\r\n        pattern = {\r\n            'com_trajectory': [],\r\n            'left_foot_trajectory': [],\r\n            'right_foot_trajectory': [],\r\n            'zmp_trajectory': [],\r\n            'timestamps': []\r\n        }\r\n\r\n        current_angle = 0\r\n        current_pos = np.array([0, 0, 0.8])\r\n\r\n        for step in range(num_steps):\r\n            # Calculate turning angle for this step\r\n            step_angle = angle * step / num_steps\r\n            next_step_angle = angle * (step + 1) / num_steps\r\n\r\n            # Calculate positions along arc\r\n            avg_angle = (current_angle + step_angle) / 2\r\n            dx = (next_step_angle - current_angle) * turn_radius * np.cos(avg_angle + np.pi/2)\r\n            dy = (next_step_angle - current_angle) * turn_radius * np.sin(avg_angle + np.pi/2)\r\n\r\n            current_pos[0] += dx\r\n            current_pos[1] += dy\r\n\r\n            # Foot positions during turn\r\n            # Simplified turning model\r\n            left_pos = current_pos + np.array([0, self.step_width, 0])\r\n            right_pos = current_pos + np.array([0, -self.step_width, 0])\r\n\r\n            pattern['com_trajectory'].append(current_pos.copy())\r\n            pattern['left_foot_trajectory'].append(left_pos)\r\n            pattern['right_foot_trajectory'].append(right_pos)\r\n            pattern['zmp_trajectory'].append(current_pos[:2].copy())\r\n            pattern['timestamps'].append(step * self.step_time)\r\n\r\n            current_angle = step_angle\r\n\r\n        # Convert to numpy arrays\r\n        for key in pattern:\r\n            if key != 'timestamps':\r\n                pattern[key] = np.array(pattern[key])\r\n\r\n        return pattern\r\n\r\n# Example usage\r\npattern_gen = WalkPatternGenerator(step_length=0.3, step_width=0.15, step_time=0.8)\r\nwalk_pattern = pattern_gen.generate_walk_pattern(4)  # 4 steps forward\r\n\r\nprint(f\"Generated walk pattern with {len(walk_pattern['com_trajectory'])} time steps\")\r\nprint(f\"Final CoM position: {walk_pattern['com_trajectory'][-1]}\")\n"})}),"\n",(0,s.jsx)(t.h2,{id:"practical-walking-controller",children:"Practical Walking Controller"}),"\n",(0,s.jsx)(t.p,{children:"A complete walking controller that combines all elements:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'class PracticalWalkingController:\r\n    """Practical walking controller combining all elements"""\r\n    def __init__(self, com_height=0.8):\r\n        self.zmp_controller = ZMPWalkingController(com_height=com_height)\r\n        self.pattern_generator = WalkPatternGenerator()\r\n        self.stepping_generator = SteppingPatternGenerator()\r\n\r\n        # Walking state\r\n        self.current_com = np.array([0, 0, com_height])\r\n        self.current_com_vel = np.array([0, 0, 0])\r\n        self.walk_speed = 0.0  # Current walking speed\r\n        self.walk_direction = 0.0  # Walking direction in radians\r\n\r\n    def start_walking(self, speed=0.3, direction=0.0):\r\n        """Start walking at specified speed and direction"""\r\n        self.walk_speed = speed\r\n        self.walk_direction = direction\r\n\r\n        # Adjust step parameters based on speed\r\n        step_time = max(0.6, 0.8 - speed * 0.2)  # Faster = shorter steps\r\n        step_length = min(0.4, speed * step_time * 0.8)  # Adjust step length\r\n\r\n        self.zmp_controller.start_walking(\r\n            step_length=step_length,\r\n            step_width=0.15,\r\n            step_time=step_time\r\n        )\r\n\r\n    def update_walking(self, sensor_data, dt):\r\n        """Main walking control update"""\r\n        # Extract sensor data\r\n        self.current_com = sensor_data.get(\'com_position\', self.current_com)\r\n        self.current_com_vel = sensor_data.get(\'com_velocity\', self.current_com_vel)\r\n\r\n        # Update ZMP-based walking controller\r\n        torques = self.zmp_controller.update_walking(self.current_com, self.current_com_vel, dt)\r\n\r\n        # Check for balance recovery needs\r\n        com_offset = np.linalg.norm(self.current_com[:2])\r\n        if com_offset > 0.15:  # Too far from center\r\n            # Generate recovery step\r\n            support_foot = self.get_current_support_foot()\r\n            recovery_step = self.stepping_generator.generate_recovery_step(\r\n                support_foot,\r\n                {\'position\': self.current_com, \'velocity\': self.current_com_vel}\r\n            )\r\n            print(f"Balance recovery step needed at: {recovery_step}")\r\n\r\n        return torques\r\n\r\n    def get_current_support_foot(self):\r\n        """Get position of current support foot"""\r\n        # This would typically come from contact sensors\r\n        # For now, we\'ll use the controller\'s internal state\r\n        if self.zmp_controller.next_foot_placement == "left":\r\n            return self.zmp_controller.right_foot_pos\r\n        else:\r\n            return self.zmp_controller.left_foot_pos\r\n\r\n    def turn_in_place(self, angle):\r\n        """Execute turning in place"""\r\n        # Generate turning pattern\r\n        turn_pattern = self.pattern_generator.generate_turning_pattern(angle)\r\n        return turn_pattern\r\n\r\n    def stop_walking(self):\r\n        """Stop walking with safe deceleration"""\r\n        self.zmp_controller.stop_walking()\r\n        self.walk_speed = 0.0\r\n\r\n# Example usage\r\ndef example_walking():\r\n    controller = PracticalWalkingController(com_height=0.85)\r\n\r\n    # Start walking forward\r\n    controller.start_walking(speed=0.4, direction=0.0)  # 0.4 m/s forward\r\n\r\n    # Simulated sensor data\r\n    sensor_data = {\r\n        \'com_position\': np.array([0.1, 0.0, 0.85]),\r\n        \'com_velocity\': np.array([0.3, 0.0, 0.0])\r\n    }\r\n\r\n    dt = 0.005  # 200 Hz\r\n\r\n    for i in range(10):  # 10 control cycles\r\n        torques = controller.update_walking(sensor_data, dt)\r\n        print(f"Control cycle {i+1}: Torques = {torques[:3]}...")  # Show first 3 torques\r\n\r\n        # Update sensor data for next cycle (simulated)\r\n        sensor_data[\'com_position\'][0] += sensor_data[\'com_velocity\'][0] * dt\r\n        sensor_data[\'com_position\'][1] += 0.001 * np.sin(i)  # Small lateral movement\r\n\r\nif __name__ == "__main__":\r\n    example_walking()\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Start with simple patterns"}),": Begin with basic stepping before complex gaits"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Prioritize stability"}),": Always ensure ZMP remains in support polygon"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Test incrementally"}),": Validate each component separately"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Consider terrain"}),": Adapt step patterns for different surfaces"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Implement safety margins"}),": Keep adequate stability margins"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Smooth transitions"}),": Ensure smooth transitions between steps"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Implement a walking controller that can adjust step length based on walking speed."}),"\n",(0,s.jsx)(t.li,{children:"Create a turning controller that maintains balance during turns."}),"\n",(0,s.jsx)(t.li,{children:"Design a disturbance recovery system that automatically takes recovery steps."}),"\n"]})]})}function _(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var r=n(6540);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);