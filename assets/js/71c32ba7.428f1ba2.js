"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[257],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},9823:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"modules/module-2-hardware/chapter-6-control-systems","title":"Chapter 6: Control Systems and Electronics","description":"Summary","source":"@site/docs/modules/module-2-hardware/chapter-6-control-systems.md","sourceDirName":"modules/module-2-hardware","slug":"/modules/module-2-hardware/chapter-6-control-systems","permalink":"/AI-Robotics-Book/docs/modules/module-2-hardware/chapter-6-control-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/modules/module-2-hardware/chapter-6-control-systems.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 5: Sensors and Perception Hardware","permalink":"/AI-Robotics-Book/docs/modules/module-2-hardware/chapter-5-sensors"},"next":{"title":"Chapter 7: Motion Planning and Locomotion","permalink":"/AI-Robotics-Book/docs/modules/module-3-control/chapter-7-motion-planning"}}');var i=r(4848),o=r(8453);const s={sidebar_position:3},l="Chapter 6: Control Systems and Electronics",a={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Introduction to Control System Architecture",id:"introduction-to-control-system-architecture",level:2},{value:"Control System Requirements",id:"control-system-requirements",level:3},{value:"Hierarchical Control Structure",id:"hierarchical-control-structure",level:3},{value:"Real-time Operating Systems",id:"real-time-operating-systems",level:2},{value:"RTOS Characteristics",id:"rtos-characteristics",level:3},{value:"Popular RTOS for Robotics",id:"popular-rtos-for-robotics",level:3},{value:"Real-time Constraints",id:"real-time-constraints",level:3},{value:"Control Loop Architectures",id:"control-loop-architectures",level:2},{value:"Single-Loop Architecture",id:"single-loop-architecture",level:3},{value:"Multi-Rate Architecture",id:"multi-rate-architecture",level:3},{value:"Hierarchical Control Architecture",id:"hierarchical-control-architecture",level:3},{value:"Power Distribution and Management",id:"power-distribution-and-management",level:2},{value:"Power Requirements Analysis",id:"power-requirements-analysis",level:3},{value:"Power Distribution Architecture",id:"power-distribution-architecture",level:3},{value:"Battery Technology and Management",id:"battery-technology-and-management",level:3},{value:"Power Optimization Strategies",id:"power-optimization-strategies",level:3},{value:"Communication Protocols",id:"communication-protocols",level:2},{value:"Internal Communication",id:"internal-communication",level:3},{value:"Middleware Protocols",id:"middleware-protocols",level:3},{value:"Safety and Redundancy Systems",id:"safety-and-redundancy-systems",level:2},{value:"Safety Mechanisms",id:"safety-mechanisms",level:3},{value:"Redundancy Strategies",id:"redundancy-strategies",level:3},{value:"Fault Detection and Recovery",id:"fault-detection-and-recovery",level:3},{value:"Technical Depth: Control Theory Applications",id:"technical-depth-control-theory-applications",level:2},{value:"PID Control for Joint Position",id:"pid-control-for-joint-position",level:3},{value:"State Feedback Control",id:"state-feedback-control",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Real-time Control Implementation",id:"real-time-control-implementation",level:3},{value:"Power Management in Practice",id:"power-management-in-practice",level:3},{value:"Communication Network Design",id:"communication-network-design",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Real-time Performance vs. Complexity",id:"real-time-performance-vs-complexity",level:3},{value:"Power Density vs. Performance",id:"power-density-vs-performance",level:3},{value:"Safety vs. Capability",id:"safety-vs-capability",level:3},{value:"Scalability vs. Cost",id:"scalability-vs-cost",level:3},{value:"Figure List",id:"figure-list",level:2},{value:"Code Example: Control System Implementation",id:"code-example-control-system-implementation",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary-1",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-6-control-systems-and-electronics",children:"Chapter 6: Control Systems and Electronics"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter explores the electronic systems and control architectures that enable humanoid robots to function effectively. We'll examine real-time control systems, power distribution, communication protocols, and safety mechanisms that form the backbone of humanoid robot operation. Understanding these systems is crucial for appreciating how hardware components are coordinated to achieve complex behaviors."}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand real-time control system architectures for humanoid robots"}),"\n",(0,i.jsx)(n.li,{children:"Analyze power distribution and management requirements"}),"\n",(0,i.jsx)(n.li,{children:"Explain communication protocols used in robotics"}),"\n",(0,i.jsx)(n.li,{children:"Design safety and redundancy systems"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate control system performance and constraints"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time Operating Systems (RTOS)"}),": Systems that guarantee response within specified time constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Control Loop Architectures"}),": Hierarchical structures for managing robot control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Power Distribution Networks"}),": Systems for delivering power to various components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication Protocols"}),": Standards for data exchange between components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Systems"}),": Mechanisms to ensure safe operation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency Requirements"}),": Timing constraints for responsive control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fault Tolerance"}),": Ability to continue operation despite component failures"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-control-system-architecture",children:"Introduction to Control System Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robots require sophisticated control systems to coordinate thousands of components in real-time. These systems must handle high-frequency control loops, manage complex sensor data, and ensure safe operation while executing complex behaviors."}),"\n",(0,i.jsx)(n.h3,{id:"control-system-requirements",children:"Control System Requirements"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Real-time Performance"}),": Critical control loops must execute within strict timing constraints\r\n",(0,i.jsx)(n.strong,{children:"High Reliability"}),": System failures could result in damage or injury\r\n",(0,i.jsx)(n.strong,{children:"Scalability"}),": Architecture must accommodate varying numbers of joints and sensors\r\n",(0,i.jsx)(n.strong,{children:"Modularity"}),": Components should be replaceable and upgradable\r\n",(0,i.jsx)(n.strong,{children:"Safety"}),": Built-in protection mechanisms for safe operation"]}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-control-structure",children:"Hierarchical Control Structure"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robot control typically follows a hierarchical structure:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"High-Level Planning"}),": Mission planning, path planning, task scheduling\r\n",(0,i.jsx)(n.strong,{children:"Mid-Level Control"}),": Trajectory generation, gait planning, behavior control\r\n",(0,i.jsx)(n.strong,{children:"Low-Level Control"}),": Joint control, sensor feedback, safety monitoring"]}),"\n",(0,i.jsx)(n.h2,{id:"real-time-operating-systems",children:"Real-time Operating Systems"}),"\n",(0,i.jsx)(n.h3,{id:"rtos-characteristics",children:"RTOS Characteristics"}),"\n",(0,i.jsx)(n.p,{children:"Real-time operating systems provide deterministic timing guarantees essential for robot control:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deterministic Scheduling"}),": Tasks execute within predictable time bounds\r\n",(0,i.jsx)(n.strong,{children:"Priority-based Scheduling"}),": Critical tasks receive precedence over less critical ones\r\n",(0,i.jsx)(n.strong,{children:"Low Latency"}),": Minimal delay between event occurrence and response\r\n",(0,i.jsx)(n.strong,{children:"Interrupt Handling"}),": Fast response to external events and sensor inputs"]}),"\n",(0,i.jsx)(n.h3,{id:"popular-rtos-for-robotics",children:"Popular RTOS for Robotics"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RT-PREEMPT Linux"}),": Real-time patch for standard Linux"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Familiar Linux environment, extensive support"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": Complex configuration, potential for non-deterministic behavior"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"VxWorks"}),": Commercial RTOS with strong real-time guarantees"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Proven in aerospace and defense applications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": Expensive, proprietary"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FreeRTOS"}),": Open-source RTOS for microcontrollers"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Free, extensive documentation, wide community"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": Limited to simpler applications"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ROS 2"}),": Robot Operating System with real-time capabilities"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Robotics-specific features, middleware, tools"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": Higher overhead than pure RTOS"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-time-constraints",children:"Real-time Constraints"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Hard Real-time"}),": Missing deadlines results in system failure"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Example: Joint position control with 1ms deadline"}),"\n",(0,i.jsx)(n.li,{children:"Consequence: Robot instability or damage"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Soft Real-time"}),": Missing deadlines degrades but doesn't fail the system"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Example: Vision processing with 30ms deadline"}),"\n",(0,i.jsx)(n.li,{children:"Consequence: Reduced performance but safe operation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"control-loop-architectures",children:"Control Loop Architectures"}),"\n",(0,i.jsx)(n.h3,{id:"single-loop-architecture",children:"Single-Loop Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Simple architecture where all control happens in one loop:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Simple to implement and debug"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": All components constrained by slowest component"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Simple robots with few joints"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"multi-rate-architecture",children:"Multi-Rate Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Different control loops operate at different frequencies:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Rate (1-10kHz)"}),": Joint position control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Medium Rate (100-500Hz)"}),": Balance control, trajectory following"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low Rate (10-50Hz)"}),": Vision processing, path planning"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"High Rate Loop (1kHz):\r\n  - Read joint encoders\r\n  - Apply position/velocity/torque control\r\n  - Send commands to actuators\r\n  - Check safety limits\r\n\r\nMedium Rate Loop (500Hz):\r\n  - Process IMU data\r\n  - Update balance control\r\n  - Track trajectory\r\n  - Check for disturbances\r\n\r\nLow Rate Loop (50Hz):\r\n  - Process camera data\r\n  - Update environment map\r\n  - Plan next actions\r\n  - Communicate with external systems\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-control-architecture",children:"Hierarchical Control Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Task Level:\r\n  - High-level mission planning\r\n  - Behavior selection\r\n  - Goal setting\r\n\r\nMotion Level:\r\n  - Trajectory generation\r\n  - Gait planning\r\n  - Whole-body motion control\r\n\r\nJoint Level:\r\n  - Individual joint control\r\n  - Motor commutation\r\n  - Safety monitoring\n"})}),"\n",(0,i.jsx)(n.h2,{id:"power-distribution-and-management",children:"Power Distribution and Management"}),"\n",(0,i.jsx)(n.h3,{id:"power-requirements-analysis",children:"Power Requirements Analysis"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actuator Power"}),": The largest power consumer in humanoid robots"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"P_actuator = \u03a3(\u03c4_i \xd7 \u03c9_i) / \u03b7_i\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where \u03c4_i is torque, \u03c9_i is velocity, and \u03b7_i is efficiency for each actuator."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Processing Power"}),": For computation and control"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CPUs: 50-200W"}),"\n",(0,i.jsx)(n.li,{children:"GPUs: 100-300W"}),"\n",(0,i.jsx)(n.li,{children:"FPGAs: 10-50W"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sensor Power"}),": For various sensors"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"IMUs: 0.1-1W"}),"\n",(0,i.jsx)(n.li,{children:"Cameras: 1-10W"}),"\n",(0,i.jsx)(n.li,{children:"LIDAR: 5-20W"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Communication Power"}),": For internal and external communication"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ethernet: 1-5W"}),"\n",(0,i.jsx)(n.li,{children:"WiFi: 2-8W"}),"\n",(0,i.jsx)(n.li,{children:"CAN bus: 0.1-1W"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"power-distribution-architecture",children:"Power Distribution Architecture"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Centralized Power System"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Single power source distributes to all components"}),"\n",(0,i.jsx)(n.li,{children:"Advantages: Simple, cost-effective"}),"\n",(0,i.jsx)(n.li,{children:"Disadvantages: Single point of failure, heavy cabling"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Distributed Power System"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple power modules distributed throughout the robot"}),"\n",(0,i.jsx)(n.li,{children:"Advantages: Reduced cabling, better fault tolerance"}),"\n",(0,i.jsx)(n.li,{children:"Disadvantages: More complex, higher cost"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"battery-technology-and-management",children:"Battery Technology and Management"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lithium-ion Batteries"}),": Most common for humanoid robots"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Energy Density"}),": 150-250 Wh/kg"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Power Density"}),": 250-400 W/kg"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cycle Life"}),": 500-2000 cycles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety"}),": Requires protection circuits"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Battery Management Systems (BMS)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cell balancing to ensure even discharge"}),"\n",(0,i.jsx)(n.li,{children:"Temperature monitoring and protection"}),"\n",(0,i.jsx)(n.li,{children:"State of charge estimation"}),"\n",(0,i.jsx)(n.li,{children:"Overcurrent and overvoltage protection"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"power-optimization-strategies",children:"Power Optimization Strategies"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Voltage Scaling"}),": Adjust voltage based on computational needs\r\n",(0,i.jsx)(n.strong,{children:"Power Gating"}),": Turn off unused components\r\n",(0,i.jsx)(n.strong,{children:"Efficient Control Algorithms"}),": Minimize unnecessary movements\r\n",(0,i.jsx)(n.strong,{children:"Energy Recovery"}),": Regenerative braking in actuators"]}),"\n",(0,i.jsx)(n.h2,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,i.jsx)(n.h3,{id:"internal-communication",children:"Internal Communication"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CAN Bus"}),": Controller Area Network"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Rate"}),": 1-2 Mbps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Robust, widely used, good for distributed control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Applications"}),": Inter-joint communication, sensor networks"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ethernet"}),": For high-bandwidth applications"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Rate"}),": 100 Mbps to 10 Gbps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": High bandwidth, standard protocol"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Applications"}),": Vision systems, external communication"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serial Communication"}),": RS-485, UART"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Rate"}),": Up to 10 Mbps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Simple, low cost"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Applications"}),": Simple sensors, actuators"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"middleware-protocols",children:"Middleware Protocols"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ROS (Robot Operating System)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Architecture"}),": Publisher-subscriber model"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Extensive tools, large community"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages"}),": Higher latency, not real-time by default"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"DDS (Data Distribution Service)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Architecture"}),": Data-centric publish-subscribe"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),": Real-time capable, scalable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Applications"}),": Safety-critical systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"safety-and-redundancy-systems",children:"Safety and Redundancy Systems"}),"\n",(0,i.jsx)(n.h3,{id:"safety-mechanisms",children:"Safety Mechanisms"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Emergency Stop"}),": Immediate power cutoff to all actuators"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hardware-based for guaranteed response"}),"\n",(0,i.jsx)(n.li,{children:"Multiple activation points for accessibility"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Current Limiting"}),": Prevents motor damage from excessive current"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implemented in motor drivers"}),"\n",(0,i.jsx)(n.li,{children:"Adjustable based on application"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Position Limits"}),": Prevents joint damage from over-extension"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implemented in control software"}),"\n",(0,i.jsx)(n.li,{children:"Can be soft (warning) or hard (immediate stop)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Temperature Monitoring"}),": Prevents component damage from overheating"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Temperature sensors on critical components"}),"\n",(0,i.jsx)(n.li,{children:"Automatic shutdown if limits exceeded"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"redundancy-strategies",children:"Redundancy Strategies"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sensor Redundancy"}),": Multiple sensors for critical measurements"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"IMU arrays for improved reliability"}),"\n",(0,i.jsx)(n.li,{children:"Multiple cameras for 360\xb0 coverage"}),"\n",(0,i.jsx)(n.li,{children:"Backup sensors for critical measurements"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actuator Redundancy"}),": Backup actuators for critical functions"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Parallel actuator systems"}),"\n",(0,i.jsx)(n.li,{children:"Fail-safe positions for critical joints"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Computational Redundancy"}),": Multiple processing units"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Primary and backup computers"}),"\n",(0,i.jsx)(n.li,{children:"Voting systems for critical decisions"}),"\n",(0,i.jsx)(n.li,{children:"Graceful degradation when components fail"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"fault-detection-and-recovery",children:"Fault Detection and Recovery"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Built-in Test (BIT)"}),": Continuous monitoring of system health"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Self-diagnostic routines"}),"\n",(0,i.jsx)(n.li,{children:"Automatic fault detection"}),"\n",(0,i.jsx)(n.li,{children:"Health reporting"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graceful Degradation"}),": System continues operation with reduced capability"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reconfiguration around failed components"}),"\n",(0,i.jsx)(n.li,{children:"Performance reduction rather than complete shutdown"}),"\n",(0,i.jsx)(n.li,{children:"Safe mode operation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"technical-depth-control-theory-applications",children:"Technical Depth: Control Theory Applications"}),"\n",(0,i.jsx)(n.h3,{id:"pid-control-for-joint-position",children:"PID Control for Joint Position"}),"\n",(0,i.jsx)(n.p,{children:"Proportional-Integral-Derivative control is fundamental for joint control:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"u(t) = K_p * e(t) + K_i * \u222be(t)dt + K_d * de(t)/dt\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"u(t) = control output"}),"\n",(0,i.jsx)(n.li,{children:"e(t) = error (desired - actual position)"}),"\n",(0,i.jsx)(n.li,{children:"K_p, K_i, K_d = controller gains"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Discrete Implementation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"u[k] = u[k-1] + K_p*(e[k] - e[k-1]) + K_i*e[k] + K_d*(e[k] - 2*e[k-1] + e[k-2])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-feedback-control",children:"State Feedback Control"}),"\n",(0,i.jsx)(n.p,{children:"For more complex systems, state feedback provides better performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"u = -K * x + r\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"u = control input"}),"\n",(0,i.jsx)(n.li,{children:"K = feedback gain matrix"}),"\n",(0,i.jsx)(n.li,{children:"x = state vector"}),"\n",(0,i.jsx)(n.li,{children:"r = reference input"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,i.jsx)(n.p,{children:"MPC optimizes control over a prediction horizon:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"min \u03a3(\u2113(x_k, u_k)) + V(x_N)\r\ns.t. x_k+1 = f(x_k, u_k)\r\n     g(x_k, u_k) \u2264 0\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where \u2113 is the stage cost, V is the terminal cost, and g represents constraints."}),"\n",(0,i.jsx)(n.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsx)(n.h3,{id:"real-time-control-implementation",children:"Real-time Control Implementation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Timing Considerations"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Control loop timing jitter should be 1% of loop period"}),"\n",(0,i.jsx)(n.li,{children:"Interrupt latency should be 10\u03bcs for critical systems"}),"\n",(0,i.jsx)(n.li,{children:"Communication delays should be predictable"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implementation Strategies"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lock memory to prevent page faults"}),"\n",(0,i.jsx)(n.li,{children:"Use real-time scheduling policies"}),"\n",(0,i.jsx)(n.li,{children:"Minimize system calls in critical loops"}),"\n",(0,i.jsx)(n.li,{children:"Use dedicated CPU cores for control"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"power-management-in-practice",children:"Power Management in Practice"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Load Balancing"}),": Distribute computational load to optimize power\r\n",(0,i.jsx)(n.strong,{children:"Dynamic Scaling"}),": Adjust performance based on current needs\r\n",(0,i.jsx)(n.strong,{children:"Predictive Management"}),": Anticipate power needs based on planned actions"]}),"\n",(0,i.jsx)(n.h3,{id:"communication-network-design",children:"Communication Network Design"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Network Topology"}),": Choose between star, ring, or bus configurations\r\n",(0,i.jsx)(n.strong,{children:"Bandwidth Allocation"}),": Prioritize critical communications\r\n",(0,i.jsx)(n.strong,{children:"Quality of Service"}),": Ensure critical data gets priority"]}),"\n",(0,i.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,i.jsx)(n.h3,{id:"real-time-performance-vs-complexity",children:"Real-time Performance vs. Complexity"}),"\n",(0,i.jsx)(n.p,{children:"Balancing sophisticated control algorithms with strict timing constraints."}),"\n",(0,i.jsx)(n.h3,{id:"power-density-vs-performance",children:"Power Density vs. Performance"}),"\n",(0,i.jsx)(n.p,{children:"Achieving high computational performance while managing power consumption."}),"\n",(0,i.jsx)(n.h3,{id:"safety-vs-capability",children:"Safety vs. Capability"}),"\n",(0,i.jsx)(n.p,{children:"Implementing safety systems without overly restricting robot capabilities."}),"\n",(0,i.jsx)(n.h3,{id:"scalability-vs-cost",children:"Scalability vs. Cost"}),"\n",(0,i.jsx)(n.p,{children:"Designing systems that can scale while maintaining reasonable costs."}),"\n",(0,i.jsx)(n.h2,{id:"figure-list",children:"Figure List"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Figure 6.1"}),": Hierarchical control architecture diagram"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Figure 6.2"}),": Real-time control loop timing diagram"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Figure 6.3"}),": Power distribution network layout"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Figure 6.4"}),": Communication protocol stack"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Figure 6.5"}),": Safety system architecture"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"code-example-control-system-implementation",children:"Code Example: Control System Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nimport time\r\nfrom typing import Dict, List, Tuple, Optional\r\nfrom dataclasses import dataclass\r\nfrom threading import Thread, Lock\r\nimport queue\r\nimport logging\r\n\r\n@dataclass\r\nclass JointState:\r\n    """Represents the state of a single joint"""\r\n    position: float  # radians\r\n    velocity: float  # rad/s\r\n    effort: float    # Nm\r\n    timestamp: float # seconds\r\n\r\n@dataclass\r\nclass ControlCommand:\r\n    """Command for a single joint"""\r\n    position: float    # desired position (radians)\r\n    velocity: float    # desired velocity (rad/s)\r\n    effort: float      # desired effort (Nm)\r\n    k_p: float = 100.0  # position gain\r\n    k_d: float = 10.0   # damping gain\r\n\r\n@dataclass\r\nclass SafetyLimits:\r\n    """Safety limits for a joint"""\r\n    min_position: float\r\n    max_position: float\r\n    max_velocity: float\r\n    max_effort: float\r\n\r\nclass PIDController:\r\n    """PID controller for joint control"""\r\n\r\n    def __init__(self, k_p: float = 1.0, k_i: float = 0.0, k_d: float = 0.0,\r\n                 output_limits: Tuple[float, float] = (-1.0, 1.0)):\r\n        self.k_p = k_p\r\n        self.k_i = k_i\r\n        self.k_d = k_d\r\n        self.output_limits = output_limits\r\n\r\n        self._last_error = 0.0\r\n        self._integral = 0.0\r\n        self._last_time = None\r\n\r\n    def update(self, setpoint: float, measurement: float, dt: float) -> float:\r\n        """Update PID controller with new measurement"""\r\n        error = setpoint - measurement\r\n\r\n        # Proportional term\r\n        p_term = self.k_p * error\r\n\r\n        # Integral term\r\n        self._integral += error * dt\r\n        i_term = self.k_i * self._integral\r\n\r\n        # Derivative term\r\n        if self._last_time is not None:\r\n            derivative = (error - self._last_error) / dt\r\n        else:\r\n            derivative = 0.0\r\n        d_term = self.k_d * derivative\r\n\r\n        # Calculate output\r\n        output = p_term + i_term + d_term\r\n\r\n        # Apply output limits\r\n        output = np.clip(output, self.output_limits[0], self.output_limits[1])\r\n\r\n        # Store values for next iteration\r\n        self._last_error = error\r\n        self._last_time = time.time()\r\n\r\n        return output\r\n\r\nclass JointController:\r\n    """Controller for a single joint with safety and communication"""\r\n\r\n    def __init__(self, joint_id: int, safety_limits: SafetyLimits):\r\n        self.joint_id = joint_id\r\n        self.safety_limits = safety_limits\r\n        self.current_state = JointState(0.0, 0.0, 0.0, 0.0)\r\n        self.command = ControlCommand(0.0, 0.0, 0.0)\r\n\r\n        # PID controllers\r\n        self.position_controller = PIDController(k_p=100.0, k_i=10.0, k_d=10.0)\r\n        self.velocity_controller = PIDController(k_p=10.0, k_i=1.0, k_d=1.0)\r\n\r\n        # Safety monitoring\r\n        self.emergency_stop = False\r\n        self.fault_detected = False\r\n\r\n        # Communication\r\n        self.command_queue = queue.Queue()\r\n        self.state_lock = Lock()\r\n\r\n    def update_state(self, state: JointState) -> None:\r\n        """Update joint state with safety checks"""\r\n        with self.state_lock:\r\n            # Safety checks\r\n            if (state.position < self.safety_limits.min_position or\r\n                state.position > self.safety_limits.max_position):\r\n                self.fault_detected = True\r\n                logging.warning(f"Joint {self.joint_id}: Position limit exceeded")\r\n\r\n            if abs(state.velocity) > self.safety_limits.max_velocity:\r\n                self.fault_detected = True\r\n                logging.warning(f"Joint {self.joint_id}: Velocity limit exceeded")\r\n\r\n            if abs(state.effort) > self.safety_limits.max_effort:\r\n                self.fault_detected = True\r\n                logging.warning(f"Joint {self.joint_id}: Effort limit exceeded")\r\n\r\n            self.current_state = state\r\n\r\n    def compute_command(self) -> float:\r\n        """Compute control command based on current state and desired position"""\r\n        if self.emergency_stop or self.fault_detected:\r\n            return 0.0  # Return zero effort in emergency\r\n\r\n        with self.state_lock:\r\n            # Update controllers based on current state\r\n            dt = time.time() - self.current_state.timestamp if self.current_state.timestamp > 0 else 0.01\r\n\r\n            # Position control\r\n            if dt > 0:\r\n                effort = self.position_controller.update(\r\n                    self.command.position,\r\n                    self.current_state.position,\r\n                    dt\r\n                )\r\n\r\n                # Apply velocity feedback\r\n                effort -= self.command.k_d * self.current_state.velocity\r\n\r\n                # Limit effort\r\n                effort = np.clip(effort, -self.safety_limits.max_effort, self.safety_limits.max_effort)\r\n\r\n                return effort\r\n            else:\r\n                return 0.0\r\n\r\n    def set_command(self, command: ControlCommand) -> None:\r\n        """Set new control command"""\r\n        # Validate command against safety limits\r\n        if (command.position < self.safety_limits.min_position or\r\n            command.position > self.safety_limits.max_position):\r\n            logging.warning(f"Commanded position out of limits for joint {self.joint_id}")\r\n            return\r\n\r\n        with self.state_lock:\r\n            self.command = command\r\n\r\n    def enable_emergency_stop(self) -> None:\r\n        """Enable emergency stop for this joint"""\r\n        self.emergency_stop = True\r\n\r\n    def disable_emergency_stop(self) -> None:\r\n        """Disable emergency stop for this joint"""\r\n        self.emergency_stop = False\r\n\r\n    def reset_fault(self) -> None:\r\n        """Reset fault condition"""\r\n        self.fault_detected = False\r\n\r\nclass RobotController:\r\n    """Main robot controller managing all joints"""\r\n\r\n    def __init__(self, num_joints: int):\r\n        self.num_joints = num_joints\r\n\r\n        # Initialize joint controllers with appropriate safety limits\r\n        self.joint_controllers = []\r\n        for i in range(num_joints):\r\n            # Example safety limits - would be specific to each joint\r\n            limits = SafetyLimits(\r\n                min_position=-np.pi,\r\n                max_position=np.pi,\r\n                max_velocity=10.0,\r\n                max_effort=100.0\r\n            )\r\n            controller = JointController(i, limits)\r\n            self.joint_controllers.append(controller)\r\n\r\n        # Control loop timing\r\n        self.control_frequency = 1000  # Hz\r\n        self.control_period = 1.0 / self.control_frequency\r\n\r\n        # Power management\r\n        self.total_power = 0.0\r\n        self.battery_level = 100.0  # Percentage\r\n\r\n        # Communication\r\n        self.comm_thread = None\r\n        self.running = False\r\n\r\n    def update_joint_states(self, joint_states: List[JointState]) -> None:\r\n        """Update states for all joints"""\r\n        if len(joint_states) != self.num_joints:\r\n            raise ValueError(f"Expected {self.num_joints} joint states, got {len(joint_states)}")\r\n\r\n        for i, state in enumerate(joint_states):\r\n            self.joint_controllers[i].update_state(state)\r\n\r\n    def compute_all_commands(self) -> List[float]:\r\n        """Compute control commands for all joints"""\r\n        efforts = []\r\n        for controller in self.joint_controllers:\r\n            effort = controller.compute_command()\r\n            efforts.append(effort)\r\n\r\n        return efforts\r\n\r\n    def set_trajectory(self, joint_commands: List[ControlCommand]) -> None:\r\n        """Set trajectory commands for all joints"""\r\n        if len(joint_commands) != self.num_joints:\r\n            raise ValueError(f"Expected {self.num_joints} commands, got {len(joint_commands)}")\r\n\r\n        for i, command in enumerate(joint_commands):\r\n            self.joint_controllers[i].set_command(command)\r\n\r\n    def emergency_stop(self) -> None:\r\n        """Emergency stop all joints"""\r\n        for controller in self.joint_controllers:\r\n            controller.enable_emergency_stop()\r\n\r\n    def enable_all_joints(self) -> None:\r\n        """Enable all joints after emergency stop"""\r\n        for controller in self.joint_controllers:\r\n            controller.disable_emergency_stop()\r\n            controller.reset_fault()\r\n\r\n    def get_system_status(self) -> Dict:\r\n        """Get overall system status"""\r\n        fault_count = sum(1 for c in self.joint_controllers if c.fault_detected)\r\n        estop_count = sum(1 for c in self.joint_controllers if c.emergency_stop)\r\n\r\n        return {\r\n            \'num_joints\': self.num_joints,\r\n            \'fault_count\': fault_count,\r\n            \'estop_count\': estop_count,\r\n            \'battery_level\': self.battery_level,\r\n            \'total_power\': self.total_power,\r\n            \'running\': self.running\r\n        }\r\n\r\n    def estimate_power_consumption(self, efforts: List[float], velocities: List[float]) -> float:\r\n        """Estimate power consumption based on efforts and velocities"""\r\n        # Simplified power model: P = sum(|effort * velocity|)\r\n        power = sum(abs(effort * velocity) for effort, velocity in zip(efforts, velocities))\r\n        return power\r\n\r\n    def run_control_loop(self) -> None:\r\n        """Run the main control loop"""\r\n        self.running = True\r\n        last_time = time.time()\r\n\r\n        while self.running:\r\n            current_time = time.time()\r\n            dt = current_time - last_time\r\n\r\n            if dt >= self.control_period:\r\n                try:\r\n                    # Get current joint states (in real system, read from hardware)\r\n                    current_states = [controller.current_state for controller in self.joint_controllers]\r\n                    velocities = [state.velocity for state in current_states]\r\n\r\n                    # Compute control commands\r\n                    efforts = self.compute_all_commands()\r\n\r\n                    # Estimate power consumption\r\n                    self.total_power = self.estimate_power_consumption(efforts, velocities)\r\n\r\n                    # Update battery level (simplified model)\r\n                    battery_drain = self.total_power * dt / 100000  # Simplified\r\n                    self.battery_level = max(0.0, self.battery_level - battery_drain)\r\n\r\n                    # Send commands to hardware (in real system)\r\n                    # self.send_commands_to_hardware(efforts)\r\n\r\n                    # Log status periodically\r\n                    if int(current_time) % 10 == 0:  # Every 10 seconds\r\n                        status = self.get_system_status()\r\n                        logging.info(f"System status: {status}")\r\n\r\n                except Exception as e:\r\n                    logging.error(f"Control loop error: {e}")\r\n                    self.emergency_stop()\r\n\r\n                last_time = current_time\r\n\r\n            # Sleep briefly to prevent busy waiting\r\n            time.sleep(0.0001)  # 100 microseconds\r\n\r\n    def start_control_loop(self) -> None:\r\n        """Start the control loop in a separate thread"""\r\n        self.comm_thread = Thread(target=self.run_control_loop)\r\n        self.comm_thread.start()\r\n\r\n    def stop_control_loop(self) -> None:\r\n        """Stop the control loop"""\r\n        self.running = False\r\n        if self.comm_thread:\r\n            self.comm_thread.join()\r\n\r\ndef simulate_robot_control() -> None:\r\n    """Simulate a simple robot control scenario"""\r\n    print("Starting robot control simulation...")\r\n\r\n    # Create robot controller for 20 joints (typical humanoid)\r\n    robot = RobotController(20)\r\n\r\n    # Initialize with some example commands\r\n    initial_commands = []\r\n    for i in range(20):\r\n        command = ControlCommand(\r\n            position=np.pi/4 if i % 2 == 0 else -np.pi/4,  # Alternate positions\r\n            velocity=0.0,\r\n            effort=0.0\r\n        )\r\n        initial_commands.append(command)\r\n\r\n    robot.set_trajectory(initial_commands)\r\n\r\n    # Simulate running for a short time\r\n    robot.start_control_loop()\r\n\r\n    # Simulate updating joint states\r\n    for step in range(100):  # 100ms simulation\r\n        # Simulate joint states (in real system, these would come from encoders)\r\n        simulated_states = []\r\n        for i in range(20):\r\n            # Simulate some movement toward commanded position\r\n            current_pos = robot.joint_controllers[i].current_state.position\r\n            commanded_pos = robot.joint_controllers[i].command.position\r\n            new_pos = current_pos + 0.1 * (commanded_pos - current_pos)\r\n\r\n            state = JointState(\r\n                position=new_pos,\r\n                velocity=0.0,  # Simplified\r\n                effort=0.0,    # Simplified\r\n                timestamp=time.time()\r\n            )\r\n            simulated_states.append(state)\r\n\r\n        robot.update_joint_states(simulated_states)\r\n        time.sleep(0.001)  # 1ms between state updates\r\n\r\n    # Stop the simulation\r\n    robot.stop_control_loop()\r\n\r\n    # Print final status\r\n    final_status = robot.get_system_status()\r\n    print(f"Final system status: {final_status}")\r\n\r\ndef analyze_control_performance(joint_controllers: List[JointController]) -> Dict:\r\n    """Analyze control system performance"""\r\n    performance_metrics = {\r\n        \'max_position_error\': 0.0,\r\n        \'avg_position_error\': 0.0,\r\n        \'max_velocity\': 0.0,\r\n        \'avg_effort\': 0.0,\r\n        \'fault_count\': 0\r\n    }\r\n\r\n    total_error = 0.0\r\n    max_velocity = 0.0\r\n    total_effort = 0.0\r\n    fault_count = 0\r\n\r\n    for controller in joint_controllers:\r\n        current_state = controller.current_state\r\n        command = controller.command\r\n\r\n        # Calculate position error\r\n        pos_error = abs(command.position - current_state.position)\r\n        total_error += pos_error\r\n        performance_metrics[\'max_position_error\'] = max(\r\n            performance_metrics[\'max_position_error\'],\r\n            pos_error\r\n        )\r\n\r\n        # Track maximum velocity\r\n        max_velocity = max(max_velocity, abs(current_state.velocity))\r\n\r\n        # Track average effort\r\n        total_effort += abs(current_state.effort)\r\n\r\n        # Count faults\r\n        if controller.fault_detected:\r\n            fault_count += 1\r\n\r\n    performance_metrics[\'avg_position_error\'] = total_error / len(joint_controllers)\r\n    performance_metrics[\'max_velocity\'] = max_velocity\r\n    performance_metrics[\'avg_effort\'] = total_effort / len(joint_controllers)\r\n    performance_metrics[\'fault_count\'] = fault_count\r\n\r\n    return performance_metrics\r\n\r\n# Example usage and demonstration\r\nif __name__ == "__main__":\r\n    # Configure logging\r\n    logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\')\r\n\r\n    print("Control Systems and Electronics - Chapter 6")\r\n    print("=" * 50)\r\n\r\n    # Demonstrate PID controller\r\n    print("\\n1. PID Controller Example:")\r\n    pid = PIDController(k_p=10.0, k_i=1.0, k_d=0.1, output_limits=(-10.0, 10.0))\r\n\r\n    # Simulate control over time\r\n    setpoint = 1.0\r\n    measurement = 0.0\r\n    dt = 0.01  # 10ms\r\n\r\n    print(f"  Setpoint: {setpoint}, Initial measurement: {measurement}")\r\n    for i in range(10):\r\n        output = pid.update(setpoint, measurement, dt)\r\n        measurement += output * dt * 0.1  # Simple plant model\r\n        print(f"  Step {i+1}: Output={output:.3f}, Measurement={measurement:.3f}")\r\n\r\n    # Demonstrate joint controller\r\n    print("\\n2. Joint Controller Example:")\r\n    safety_limits = SafetyLimits(\r\n        min_position=-2.0,\r\n        max_position=2.0,\r\n        max_velocity=5.0,\r\n        max_effort=50.0\r\n    )\r\n\r\n    joint_ctrl = JointController(0, safety_limits)\r\n    command = ControlCommand(position=1.0, velocity=0.0, effort=0.0)\r\n    joint_ctrl.set_command(command)\r\n\r\n    # Simulate state updates\r\n    for i in range(5):\r\n        state = JointState(\r\n            position=0.2 * i,  # Simulate movement\r\n            velocity=0.2,\r\n            effort=5.0,\r\n            timestamp=time.time()\r\n        )\r\n        joint_ctrl.update_state(state)\r\n        effort = joint_ctrl.compute_command()\r\n        print(f"  State update {i+1}: Position={state.position:.2f}, Commanded effort={effort:.2f}")\r\n\r\n    # Demonstrate robot controller\r\n    print("\\n3. Robot Controller Example:")\r\n    robot = RobotController(6)  # 6 joints for example\r\n\r\n    # Set initial commands\r\n    commands = []\r\n    for i in range(6):\r\n        cmd = ControlCommand(position=i * 0.5, velocity=0.0, effort=0.0)\r\n        commands.append(cmd)\r\n    robot.set_trajectory(commands)\r\n\r\n    # Update with simulated states\r\n    states = []\r\n    for i in range(6):\r\n        state = JointState(\r\n            position=i * 0.4,  # Slightly different from command\r\n            velocity=0.1,\r\n            effort=2.0,\r\n            timestamp=time.time()\r\n        )\r\n        states.append(state)\r\n    robot.update_joint_states(states)\r\n\r\n    # Compute commands\r\n    efforts = robot.compute_all_commands()\r\n    print(f"  Computed efforts for 6 joints: {[f\'{e:.2f}\' for e in efforts]}")\r\n\r\n    # Analyze performance\r\n    performance = analyze_control_performance(robot.joint_controllers)\r\n    print(f"  Performance metrics: {performance}")\r\n\r\n    # Show system status\r\n    status = robot.get_system_status()\r\n    print(f"  System status: {status}")\r\n\r\n    print("\\n4. Control Simulation:")\r\n    simulate_robot_control()\r\n\r\n    print("\\nControl Systems implementation completed successfully!")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Design a control system architecture for a 20-degree-of-freedom humanoid robot with real-time constraints."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Calculate the power requirements for a humanoid robot with 20 servo actuators, each drawing 5A at 24V during maximum load."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Implement a simple state machine for a robot's safety system with normal, warning, and emergency states."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary-1",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter provided a comprehensive overview of control systems and electronics in humanoid robotics, covering real-time control architectures, power distribution, communication protocols, and safety mechanisms. Understanding these systems is essential for developing effective humanoid robots that can operate safely and reliably in complex environments. The mathematical models and practical examples presented will help in designing and implementing control systems for specific applications."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);