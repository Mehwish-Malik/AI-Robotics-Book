"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[572],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var o=r(6540);const t={},a=o.createContext(t);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(a.Provider,{value:n},e.children)}},8936:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>_,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"tutorials/basic-control-examples/balance-control","title":"Balance Control","description":"Overview","source":"@site/docs/tutorials/basic-control-examples/balance-control.md","sourceDirName":"tutorials/basic-control-examples","slug":"/tutorials/basic-control-examples/balance-control","permalink":"/AI-Robotics-Book/docs/tutorials/basic-control-examples/balance-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/tutorials/basic-control-examples/balance-control.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3}}');var t=r(4848),a=r(8453);const s={sidebar_position:3},l="Balance Control",i={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Balance Fundamentals",id:"balance-fundamentals",level:2},{value:"Center of Mass (CoM) and Support Polygon",id:"center-of-mass-com-and-support-polygon",level:3},{value:"Zero Moment Point (ZMP) Control",id:"zero-moment-point-zmp-control",level:3},{value:"Simple Balance Controller",id:"simple-balance-controller",level:2},{value:"Inverted Pendulum Model",id:"inverted-pendulum-model",level:2},{value:"Whole-Body Balance Control",id:"whole-body-balance-control",level:2},{value:"Reactive Balance Control",id:"reactive-balance-control",level:2},{value:"Practical Implementation Example",id:"practical-implementation-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"balance-control",children:"Balance Control"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Balance control is critical for humanoid robots to maintain stability during static and dynamic activities. This tutorial covers fundamental balance control concepts including center of mass control, zero moment point (ZMP) control, and reactive balance strategies."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this tutorial, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the principles of static and dynamic balance"}),"\n",(0,t.jsx)(n.li,{children:"Implement ZMP-based balance control"}),"\n",(0,t.jsx)(n.li,{children:"Design reactive balance strategies for perturbations"}),"\n",(0,t.jsx)(n.li,{children:"Apply whole-body control for balance maintenance"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"balance-fundamentals",children:"Balance Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"center-of-mass-com-and-support-polygon",children:"Center of Mass (CoM) and Support Polygon"}),"\n",(0,t.jsx)(n.p,{children:"For a humanoid robot to maintain balance, its center of mass must remain within the support polygon (the convex hull of all contact points with the ground)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.spatial import ConvexHull\r\n\r\ndef calculate_support_polygon(left_foot_pos, right_foot_pos):\r\n    """\r\n    Calculate the support polygon for bipedal stance\r\n    """\r\n    # Create points for both feet (simplified as rectangles)\r\n    left_points = [\r\n        [left_foot_pos[0] + 0.1, left_foot_pos[1] + 0.05],  # front-left\r\n        [left_foot_pos[0] + 0.1, left_foot_pos[1] - 0.05],  # front-right\r\n        [left_foot_pos[0] - 0.1, left_foot_pos[1] - 0.05],  # back-right\r\n        [left_foot_pos[0] - 0.1, left_foot_pos[1] + 0.05],  # back-left\r\n    ]\r\n\r\n    right_points = [\r\n        [right_foot_pos[0] + 0.1, right_foot_pos[1] + 0.05],\r\n        [right_foot_pos[0] + 0.1, right_foot_pos[1] - 0.05],\r\n        [right_foot_pos[0] - 0.1, right_foot_pos[1] - 0.05],\r\n        [right_foot_pos[0] - 0.1, right_foot_pos[1] + 0.05],\r\n    ]\r\n\r\n    all_points = left_points + right_points\r\n    hull = ConvexHull(all_points)\r\n    return np.array(all_points)[hull.vertices]\r\n\r\ndef is_balanced(com_pos, support_polygon):\r\n    """\r\n    Check if center of mass is within support polygon\r\n    """\r\n    from matplotlib.path import Path\r\n    path = Path(support_polygon)\r\n    return path.contains_point(com_pos[:2])\n'})}),"\n",(0,t.jsx)(n.h3,{id:"zero-moment-point-zmp-control",children:"Zero Moment Point (ZMP) Control"}),"\n",(0,t.jsx)(n.p,{children:"The Zero Moment Point is the point on the ground where the moment of the ground reaction force equals zero:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def compute_zmp(com_pos, com_acc, z_height=0.8, gravity=9.81):\r\n    """\r\n    Compute Zero Moment Point from CoM position and acceleration\r\n    """\r\n    # ZMP = CoM - (h/g) * CoM_acc\r\n    zmp_x = com_pos[0] - (z_height / gravity) * com_acc[0]\r\n    zmp_y = com_pos[1] - (z_height / gravity) * com_acc[1]\r\n    return np.array([zmp_x, zmp_y, 0])\r\n\r\ndef zmp_stability_check(zmp, support_polygon, margin=0.05):\r\n    """\r\n    Check if ZMP is within support polygon with safety margin\r\n    """\r\n    from matplotlib.path import Path\r\n    # Create a smaller polygon with margin\r\n    center = np.mean(support_polygon, axis=0)\r\n    shrunk_polygon = center + (1 - margin) * (support_polygon - center)\r\n    path = Path(shrunk_polygon)\r\n    return path.contains_point(zmp[:2])\n'})}),"\n",(0,t.jsx)(n.h2,{id:"simple-balance-controller",children:"Simple Balance Controller"}),"\n",(0,t.jsx)(n.p,{children:"A basic balance controller that adjusts CoM position:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class SimpleBalanceController:\r\n    def __init__(self, com_height=0.8, gravity=9.81):\r\n        self.com_height = com_height\r\n        self.gravity = gravity\r\n        self.omega = np.sqrt(gravity / com_height)\r\n\r\n        # PID controllers for balance\r\n        self.x_pid = PIDController(kp=10.0, ki=1.0, kd=2.0)\r\n        self.y_pid = PIDController(kp=10.0, ki=1.0, kd=2.0)\r\n\r\n        self.previous_com_pos = np.zeros(3)\r\n        self.previous_com_vel = np.zeros(3)\r\n\r\n    def compute_balance_torques(self, current_com_pos, desired_com_pos, dt):\r\n        """\r\n        Compute torques needed for balance control\r\n        """\r\n        # Compute error in CoM position\r\n        pos_error = desired_com_pos[:2] - current_com_pos[:2]\r\n\r\n        # Use PID to compute corrective torques\r\n        torque_x = self.x_pid.update(desired_com_pos[0], current_com_pos[0], dt)\r\n        torque_y = self.y_pid.update(desired_com_pos[1], current_com_pos[1], dt)\r\n\r\n        return np.array([torque_x, torque_y, 0])\r\n\r\n    def update_com_state(self, current_com_pos, dt):\r\n        """\r\n        Update CoM velocity and acceleration estimates\r\n        """\r\n        if hasattr(self, \'previous_com_pos\'):\r\n            current_vel = (current_com_pos - self.previous_com_pos) / dt\r\n            if hasattr(self, \'previous_com_vel\'):\r\n                current_acc = (current_vel - self.previous_com_vel) / dt\r\n            else:\r\n                current_acc = np.zeros(3)\r\n        else:\r\n            current_vel = np.zeros(3)\r\n            current_acc = np.zeros(3)\r\n\r\n        self.previous_com_vel = current_vel\r\n        self.previous_com_pos = current_com_pos\r\n\r\n        return current_vel, current_acc\n'})}),"\n",(0,t.jsx)(n.h2,{id:"inverted-pendulum-model",children:"Inverted Pendulum Model"}),"\n",(0,t.jsx)(n.p,{children:"The inverted pendulum is a fundamental model for balance control:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class InvertedPendulumModel:\r\n    def __init__(self, height=0.8, gravity=9.81):\r\n        self.height = height\r\n        self.gravity = gravity\r\n        self.omega = np.sqrt(gravity / height)\r\n\r\n    def integrate_motion(self, zmp_ref, dt, current_com, current_vel):\r\n        """\r\n        Integrate inverted pendulum dynamics\r\n        """\r\n        # \u1e8d = \u03c9\xb2 * (x - zmp)\r\n        com_acc = self.omega**2 * (current_com[:2] - zmp_ref)\r\n\r\n        # Update velocity and position\r\n        new_vel = current_vel[:2] + com_acc * dt\r\n        new_pos = current_com[:2] + new_vel * dt + 0.5 * com_acc * dt**2\r\n\r\n        # Return new CoM position (with z unchanged) and velocity\r\n        new_com = np.array([new_pos[0], new_pos[1], current_com[2]])\r\n        new_vel_full = np.array([new_vel[0], new_vel[1], current_vel[2]])\r\n\r\n        return new_com, new_vel_full, np.concatenate([com_acc, np.array([0])])\r\n\r\n    def compute_zmp(self, com_pos, com_acc):\r\n        """\r\n        Compute ZMP from CoM state\r\n        """\r\n        # ZMP = CoM - (h/g) * CoM_acc\r\n        zmp = com_pos[:2] - (self.height / self.gravity) * com_acc[:2]\r\n        return zmp\n'})}),"\n",(0,t.jsx)(n.h2,{id:"whole-body-balance-control",children:"Whole-Body Balance Control"}),"\n",(0,t.jsx)(n.p,{children:"Coordinating multiple joints for balance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class WholeBodyBalanceController:\r\n    def __init__(self, robot_model):\r\n        self.robot_model = robot_model\r\n        self.balance_controller = SimpleBalanceController()\r\n        self.pendulum_model = InvertedPendulumModel()\r\n\r\n        # Joint weighting for balance (torso and legs more important for balance)\r\n        self.balance_weights = np.array([2.0, 2.0, 2.0,  # torso\r\n                                        1.5, 1.5, 1.5,  # legs\r\n                                        0.5, 0.5, 0.5,  # arms\r\n                                        0.1, 0.1])      # head\r\n\r\n    def compute_balance_joints(self, current_config, desired_com, current_com, dt):\r\n        """\r\n        Compute joint adjustments for balance maintenance\r\n        """\r\n        # Calculate CoM error\r\n        com_error = desired_com[:2] - current_com[:2]\r\n\r\n        # Map CoM error to joint space using Jacobian\r\n        jacobian = self.robot_model.compute_com_jacobian(current_config)\r\n\r\n        # Weighted pseudo-inverse for prioritized control\r\n        weights = np.diag(self.balance_weights)\r\n        weighted_jacobian = weights @ jacobian\r\n        joint_correction = np.linalg.pinv(weighted_jacobian) @ np.concatenate([com_error, np.zeros(4)])\r\n\r\n        # Apply limits to prevent excessive joint movements\r\n        joint_correction = np.clip(joint_correction, -0.1, 0.1)  # Limit to 0.1 rad adjustments\r\n\r\n        return joint_correction\r\n\r\n    def compute_balance_strategy(self, current_state, support_polygon, dt):\r\n        """\r\n        Determine appropriate balance strategy based on stability margin\r\n        """\r\n        # Calculate distance from CoM to support polygon boundary\r\n        com_pos = current_state[\'com_position\']\r\n        from matplotlib.path import Path\r\n        path = Path(support_polygon)\r\n\r\n        if not path.contains_point(com_pos[:2]):\r\n            # CoM is outside support - stepping strategy needed\r\n            return "stepping"\r\n        else:\r\n            # Calculate distance to boundary\r\n            distances = []\r\n            for i in range(len(support_polygon)):\r\n                p1 = support_polygon[i]\r\n                p2 = support_polygon[(i + 1) % len(support_polygon)]\r\n                dist = self.point_to_line_distance(com_pos[:2], p1, p2)\r\n                distances.append(dist)\r\n\r\n            min_distance = min(distances)\r\n\r\n            if min_distance < 0.05:  # Less than 5cm from edge\r\n                return "hip_strategy"  # Use hip movements\r\n            else:\r\n                return "ankle_strategy"  # Use ankle adjustments\r\n\r\n    def point_to_line_distance(self, point, line_start, line_end):\r\n        """\r\n        Calculate distance from point to line segment\r\n        """\r\n        # Vector from line_start to point\r\n        v = point - line_start\r\n        # Vector along line\r\n        s = line_end - line_start\r\n\r\n        # Project v onto s\r\n        proj_len = np.dot(v, s) / np.dot(s, s)\r\n\r\n        if proj_len < 0:\r\n            # Closest point is line_start\r\n            return np.linalg.norm(point - line_start)\r\n        elif proj_len > 1:\r\n            # Closest point is line_end\r\n            return np.linalg.norm(point - line_end)\r\n        else:\r\n            # Closest point is along line\r\n            closest = line_start + proj_len * s\r\n            return np.linalg.norm(point - closest)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"reactive-balance-control",children:"Reactive Balance Control"}),"\n",(0,t.jsx)(n.p,{children:"Reacting to external disturbances:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class ReactiveBalanceController:\r\n    def __init__(self):\r\n        self.disturbance_threshold = 50.0  # Newtons\r\n        self.recovery_active = False\r\n        self.recovery_start_time = 0.0\r\n\r\n    def detect_disturbance(self, force_sensors, torque_sensors, time):\r\n        """\r\n        Detect external disturbances using sensor data\r\n        """\r\n        total_force = np.linalg.norm(force_sensors)\r\n        total_torque = np.linalg.norm(torque_sensors)\r\n\r\n        return (total_force > self.disturbance_threshold or\r\n                total_torque > self.disturbance_threshold * 0.1)\r\n\r\n    def compute_recovery_action(self, current_state, disturbance_direction, strategy="ankle"):\r\n        """\r\n        Compute recovery action based on disturbance\r\n        """\r\n        if strategy == "ankle":\r\n            # Ankle strategy: Use ankle torques for small disturbances\r\n            recovery_torque = -disturbance_direction * 20  # Proportional to disturbance\r\n            return np.array([recovery_torque[0], recovery_torque[1], 0, 0, 0, 0])  # Ankle torques\r\n        elif strategy == "hip":\r\n            # Hip strategy: Use hip movements for medium disturbances\r\n            hip_torque = -disturbance_direction * 50\r\n            return np.array([0, 0, 0, hip_torque[0], hip_torque[1], 0])  # Hip torques\r\n        elif strategy == "stepping":\r\n            # Stepping strategy: Plan a step to expand support base\r\n            step_direction = -disturbance_direction\r\n            step_size = min(0.3, np.linalg.norm(step_direction) * 0.5)  # Max 30cm step\r\n            return step_direction / (np.linalg.norm(step_direction) + 1e-6) * step_size\r\n\r\n    def select_recovery_strategy(self, com_state, support_polygon, disturbance_magnitude):\r\n        """\r\n        Select appropriate recovery strategy based on situation\r\n        """\r\n        from matplotlib.path import Path\r\n        path = Path(support_polygon)\r\n\r\n        com_in_support = path.contains_point(com_state[:2])\r\n\r\n        if disturbance_magnitude > 100:  # Large disturbance\r\n            return "stepping"\r\n        elif not com_in_support or disturbance_magnitude > 50:  # Medium disturbance\r\n            return "hip"\r\n        else:  # Small disturbance\r\n            return "ankle"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practical-implementation-example",children:"Practical Implementation Example"}),"\n",(0,t.jsx)(n.p,{children:"Putting it all together in a practical balance controller:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class PracticalBalanceController:\r\n    def __init__(self, com_height=0.8):\r\n        self.inverted_pendulum = InvertedPendulumModel(height=com_height)\r\n        self.whole_body_controller = WholeBodyBalanceController(robot_model=None)  # Simplified\r\n        self.reactive_controller = ReactiveBalanceController()\r\n\r\n        # Balance control parameters\r\n        self.com_reference = np.array([0.0, 0.0, com_height])\r\n        self.max_balance_torque = 100.0\r\n        self.balance_gains = np.array([50.0, 50.0, 20.0])  # For different directions\r\n\r\n    def update_balance(self, sensor_data, joint_positions, dt):\r\n        \"\"\"\r\n        Main balance control update function\r\n        \"\"\"\r\n        # Extract sensor data\r\n        current_com = sensor_data['com_position']\r\n        current_com_vel = sensor_data['com_velocity']\r\n        current_com_acc = sensor_data['com_acceleration']\r\n        support_polygon = sensor_data['support_polygon']\r\n        force_sensors = sensor_data.get('force_sensors', np.zeros(6))\r\n        torque_sensors = sensor_data.get('torque_sensors', np.zeros(6))\r\n\r\n        # Detect disturbances\r\n        if self.reactive_controller.detect_disturbance(force_sensors, torque_sensors, 0):\r\n            # Use reactive control for disturbances\r\n            disturbance_direction = force_sensors[:2] / (np.linalg.norm(force_sensors[:2]) + 1e-6)\r\n            strategy = self.reactive_controller.select_recovery_strategy(\r\n                current_com, support_polygon, np.linalg.norm(force_sensors)\r\n            )\r\n            recovery_action = self.reactive_controller.compute_recovery_action(\r\n                current_com, disturbance_direction, strategy\r\n            )\r\n            return recovery_action\r\n\r\n        # Normal balance control\r\n        else:\r\n            # Calculate ZMP\r\n            current_zmp = self.inverted_pendulum.compute_zmp(current_com, current_com_acc)\r\n\r\n            # Check stability\r\n            is_stable = zmp_stability_check(current_zmp, support_polygon)\r\n\r\n            if not is_stable:\r\n                # Need to adjust CoM to bring ZMP back to safe region\r\n                center_of_support = np.mean(support_polygon, axis=0)\r\n                desired_zmp = center_of_support[:2]\r\n\r\n                # Use inverted pendulum model to determine CoM adjustment needed\r\n                desired_com = current_com.copy()\r\n                desired_com[:2] = desired_zmp + (self.inverted_pendulum.height / self.inverted_pendulum.gravity) * current_com_acc[:2]\r\n\r\n                # Compute balance torques\r\n                balance_torques = self.compute_balance_torques(\r\n                    current_com, desired_com, dt\r\n                )\r\n\r\n                return np.clip(balance_torques, -self.max_balance_torque, self.max_balance_torque)\r\n            else:\r\n                # System is stable, return minimal corrective torques\r\n                return np.zeros(6)  # No additional torque needed\r\n\r\n    def compute_balance_torques(self, current_com, desired_com, dt):\r\n        \"\"\"\r\n        Compute balance torques using PID control\r\n        \"\"\"\r\n        # Calculate error\r\n        pos_error = desired_com[:2] - current_com[:2]\r\n\r\n        # Simple proportional control (in practice, you'd use a more sophisticated controller)\r\n        torques = self.balance_gains[:2] * pos_error\r\n        torques = np.append(torques, np.zeros(4))  # Add zeros for other axes\r\n\r\n        return torques\r\n\r\n# Example usage\r\ndef example_balance_control():\r\n    controller = PracticalBalanceController(com_height=0.85)\r\n\r\n    # Simulated sensor data\r\n    sensor_data = {\r\n        'com_position': np.array([0.02, -0.01, 0.85]),\r\n        'com_velocity': np.array([0.01, -0.005, 0]),\r\n        'com_acceleration': np.array([0.1, -0.05, 0]),\r\n        'support_polygon': np.array([[0.1, 0.1], [0.1, -0.1], [-0.1, -0.1], [-0.1, 0.1]]),\r\n        'force_sensors': np.array([5, -3, 0, 0, 0, 0]),\r\n        'torque_sensors': np.array([2, -1, 0, 0, 0, 0])\r\n    }\r\n\r\n    joint_positions = np.zeros(20)  # 20 joint robot\r\n    dt = 0.005  # 200 Hz control rate\r\n\r\n    balance_torques = controller.update_balance(sensor_data, joint_positions, dt)\r\n    print(f\"Balance torques: {balance_torques}\")\r\n\r\nif __name__ == \"__main__\":\r\n    example_balance_control()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start simple"}),": Begin with basic CoM control before implementing complex strategies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prioritize safety"}),": Always have emergency stop mechanisms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test incrementally"}),": Validate each component separately before integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider multiple strategies"}),": Use different approaches for different disturbance magnitudes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate in simulation"}),": Test extensively in simulation before real robot deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor stability margins"}),": Keep adequate safety margins in all conditions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Implement a balance controller that switches between ankle and hip strategies based on disturbance magnitude."}),"\n",(0,t.jsx)(n.li,{children:"Create a ZMP trajectory generator for walking patterns."}),"\n",(0,t.jsx)(n.li,{children:"Design a balance controller that considers angular momentum for more robust stability."}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);