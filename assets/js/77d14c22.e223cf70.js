"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[123],{2779:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"modules/module-3-control/chapter-9-balance","title":"Chapter 9: Balance and Stability Control","description":"Summary","source":"@site/docs/modules/module-3-control/chapter-9-balance.md","sourceDirName":"modules/module-3-control","slug":"/modules/module-3-control/chapter-9-balance","permalink":"/docs/modules/module-3-control/chapter-9-balance","draft":false,"unlisted":false,"editUrl":"https://github.com/Mehwish-Malik/AI-Robotics-Book/tree/main/docs/modules/module-3-control/chapter-9-balance.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 8: Locomotion and Gait Control","permalink":"/docs/modules/module-3-control/chapter-8-locomotion"},"next":{"title":"Chapter 10: Computer Vision and Perception","permalink":"/docs/modules/module-4-ai/chapter-10-perception"}}');var o=r(4848),a=r(8453);const i={sidebar_position:3},l="Chapter 9: Balance and Stability Control",s={},c=[{value:"Summary",id:"summary",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Introduction to Balance Control",id:"introduction-to-balance-control",level:2},{value:"Balance Fundamentals",id:"balance-fundamentals",level:3},{value:"Balance Control Challenges",id:"balance-control-challenges",level:3},{value:"Feedback Control Systems",id:"feedback-control-systems",level:2},{value:"Proportional-Integral-Derivative (PID) Control",id:"proportional-integral-derivative-pid-control",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-9-balance-and-stability-control",children:"Chapter 9: Balance and Stability Control"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter examines the critical systems that enable humanoid robots to maintain stability and balance during static and dynamic conditions. We'll explore feedback and feedforward control strategies, disturbance rejection techniques, and recovery mechanisms that allow robots to maintain equilibrium in the face of internal and external disturbances. Understanding balance control is fundamental to creating safe and capable humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the principles of static and dynamic balance control"}),"\n",(0,o.jsx)(e.li,{children:"Analyze different feedback and feedforward control strategies"}),"\n",(0,o.jsx)(e.li,{children:"Design controllers for disturbance rejection and recovery"}),"\n",(0,o.jsx)(e.li,{children:"Implement multi-level control hierarchies for balance"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate balance performance and stability margins"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Static Balance"}),": Stability without motion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Balance"}),": Stability maintained through active control during motion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Feedback Control"}),": Control based on measured system state"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Feedforward Control"}),": Control based on predicted or desired behavior"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Disturbance Rejection"}),": Ability to maintain balance despite external forces"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Strategies"}),": Methods to regain balance after disturbances"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stability Margins"}),": Quantitative measures of balance robustness"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Control Hierarchies"}),": Multi-level control structures for balance"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-balance-control",children:"Introduction to Balance Control"}),"\n",(0,o.jsx)(e.p,{children:"Balance control in humanoid robots involves maintaining the center of mass (CoM) within the support polygon while executing tasks. Unlike static structures, humanoid robots actively control balance via coordinated joint movements and sophisticated algorithms."}),"\n",(0,o.jsx)(e.h3,{id:"balance-fundamentals",children:"Balance Fundamentals"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Support Polygon"}),": Convex hull of contact points with the ground"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass (CoM)"}),": Point representing the robot\u2019s total mass"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Ground reaction point with zero moment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Capture Point"}),": Step point required to stop motion"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"balance-control-challenges",children:"Balance Control Challenges"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"High-Dimensional Systems"}),"\n",(0,o.jsx)(e.li,{children:"Underactuation"}),"\n",(0,o.jsx)(e.li,{children:"Real-time Requirements"}),"\n",(0,o.jsx)(e.li,{children:"Uncertainty"}),"\n",(0,o.jsx)(e.li,{children:"Safety"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"feedback-control-systems",children:"Feedback Control Systems"}),"\n",(0,o.jsx)(e.h3,{id:"proportional-integral-derivative-pid-control",children:"Proportional-Integral-Derivative (PID) Control"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"u_t = Kp * e + Ki * integral(e dt) + Kd * derivative(e)\r\nWhere:\r\n\r\nu_t: control output\r\n\r\ne: error (desired - actual)\r\n\r\nKp, Ki, Kd: controller gains\r\n\r\nState Feedback Control\r\npython\r\nCopy code\r\nu = -K @ x + r\r\nWhere:\r\n\r\nu: control input\r\n\r\nK: feedback gain matrix\r\n\r\nx: state vector\r\n\r\nr: reference input\r\n\r\nAdaptive Control\r\npython\r\nCopy code\r\ntheta_dot = -Gamma * phi * e\r\nWhere:\r\n\r\ntheta: parameter vector\r\n\r\nGamma: adaptation gain\r\n\r\nphi: regressor vector\r\n\r\ne: tracking error\r\n\r\nFeedforward Control Strategies\r\nPreview Control\r\npython\r\nCopy code\r\nu_k = -K @ x_k - Kf * sum(Gf[i] * r[k+i] for i in range(N))\r\nWhere:\r\n\r\nN: preview horizon\r\n\r\nr: reference trajectory\r\n\r\nKf, Gf: preview control gains\r\n\r\nFeedforward Compensation\r\npython\r\nCopy code\r\ntau_gravity = G(q)\r\ntau_coriolis = C(q, q_dot) @ q_dot\r\ntau_disturbance = F_external\r\nTrajectory-Based Feedforward\r\npython\r\nCopy code\r\ntau = M(q) @ (q_ddot_desired + Kv * (q_dot_desired - q_dot) + Kp * (q_desired - q))\r\nDisturbance Rejection\r\nDisturbance Observer\r\npython\r\nCopy code\r\nd_hat = L_s * (y - y_hat)\r\nRobust Control\r\npython\r\nCopy code\r\n# H-infinity control\r\n||T_wd||_inf < gamma\r\n\r\n# Mu-synthesis\r\nmu_Delta(T) < 1\r\nRecovery from Perturbations\r\nAnkle Strategy: small disturbances\r\n\r\nHip Strategy: medium disturbances\r\n\r\nStepping Strategy: take a step\r\n\r\nSuspension Strategy: move CoM\r\n\r\nMulti-Level Control Hierarchy\r\nHigh-Level: Step planning, CoM trajectory\r\n\r\nMid-Level: ZMP/Capture point control, whole-body control\r\n\r\nLow-Level: Joint-level PID, sensor processing\r\n\r\nTechnical Foundations\r\nLinear Inverted Pendulum Model\r\n\ud835\udc65\r\n\xa8\r\n\ud835\udc50\r\n\ud835\udc5c\r\n\ud835\udc5a\r\n=\r\n\ud835\udf14\r\n2\r\n(\r\n\ud835\udc65\r\n\ud835\udc50\r\n\ud835\udc5c\r\n\ud835\udc5a\r\n\u2212\r\n\ud835\udc65\r\n\ud835\udc67\r\n\ud835\udc5a\r\n\ud835\udc5d\r\n)\r\n\ud835\udc66\r\n\xa8\r\n\ud835\udc50\r\n\ud835\udc5c\r\n\ud835\udc5a\r\n=\r\n\ud835\udf14\r\n2\r\n(\r\n\ud835\udc66\r\n\ud835\udc50\r\n\ud835\udc5c\r\n\ud835\udc5a\r\n\u2212\r\n\ud835\udc66\r\n\ud835\udc67\r\n\ud835\udc5a\r\n\ud835\udc5d\r\n)\r\nx\r\n\xa8\r\n  \r\ncom\r\n\u200b\r\n =\u03c9 \r\n2\r\n (x \r\ncom\r\n\u200b\r\n \u2212x \r\nzmp\r\n\u200b\r\n ) \r\ny\r\n\xa8\r\n\u200b\r\n  \r\ncom\r\n\u200b\r\n =\u03c9 \r\n2\r\n (y \r\ncom\r\n\u200b\r\n \u2212y \r\nzmp\r\n\u200b\r\n )\r\nWhere omega^2 = g / h.\r\n\r\nState-Space Representation\r\npython\r\nCopy code\r\nx_dot = A @ x + B @ u + Bd @ d\r\ny = C @ x + D @ u\r\nOptimal Control\r\npython\r\nCopy code\r\nJ = \u222b[x.T @ Q @ x + u.T @ R @ u] dt\r\nu = -R_inv @ B.T @ P @ x\r\nPractical Applications\r\nStanding Balance\r\n\r\nWalking Balance\r\n\r\nManipulation Balance\r\n\r\nRecovery Scenarios\r\n\r\nChallenges\r\nControl Complexity\r\n\r\nReal-time Performance\r\n\r\nModeling Uncertainty\r\n\r\nSafety vs Performance\r\n\r\nExercises\r\nImplement a balance controller switching between ankle and hip strategies.\r\n\r\nDesign a disturbance observer for humanoid robots.\r\n\r\nCreate a multi-level balance control system.\r\n\r\nCode Example: Safe Python Implementation\r\npython\r\nCopy code\r\nimport numpy as np\r\nfrom dataclasses import dataclass\r\n\r\n@dataclass\r\nclass BalanceState:\r\n    com_pos: np.ndarray\r\n    com_vel: np.ndarray\r\n    zmp_pos: np.ndarray\r\n    timestamp: float = 0.0\r\n\r\n@dataclass\r\nclass BalanceController:\r\n    kp: float = 10.0\r\n\r\n    def update(self, state: BalanceState, dt: float):\r\n        error = np.zeros(2)\r\n        control_output = self.kp * error\r\n        state.timestamp += dt\r\n        return control_output\r\nSummary\r\n\r\nThis chapter provided a comprehensive overview of balance and stability control for humanoid robots, covering feedback and feedforward control strategies, disturbance rejection techniques, and recovery mechanisms. We explored mathematical models, control algorithms, and multi-level control hierarchies essential for maintaining robot stability. The concepts and implementations presented will help in developing robust balance control systems for humanoid robots that can maintain equilibrium in various conditions and recover from disturbances safely.ge\n"})})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>l});var t=r(6540);const o={},a=t.createContext(o);function i(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);